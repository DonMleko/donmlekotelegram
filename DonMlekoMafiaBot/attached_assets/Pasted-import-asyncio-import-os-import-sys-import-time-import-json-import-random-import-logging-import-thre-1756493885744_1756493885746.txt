import asyncio
import os
import sys
import time
import json
import random
import logging
import threading
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters, CallbackQueryHandler
from telegram.error import NetworkError, TimedOut
import aiohttp
from aiohttp import web

# Konfiguracja logowania
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# --- Token API z zmiennej Å›rodowiskowej ---
TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise RuntimeError("Missing BOT_TOKEN environment variable! Set it in Replit Secrets.")

# --- Baza danych uÅ¼ytkownikÃ³w ---
USER_DATA_FILE = "user_data.json"

# === ANTI-BOT PROTECTION ===
USER_ACTIVITY_LIMITS = {
    'commands_per_minute': 20,  # Max 20 komend na minutÄ™
    'points_per_hour': 200,     # Max 200 punktÃ³w na godzinÄ™ z podstawowych komend
    'daily_limit': 1000         # Max 1000 punktÃ³w dziennie z podstawowych aktywnoÅ›ci
}

def check_rate_limit(user_id, command_type="general"):
    """Sprawdza czy uÅ¼ytkownik nie przekracza limitÃ³w aktywnoÅ›ci"""
    try:
        user_data = get_user_data_full(user_id)
        now = time.time()

        # Inicjalizuj tracking jeÅ›li nie istnieje
        if 'activity_tracking' not in user_data:
            user_data['activity_tracking'] = {
                'last_reset': now,
                'commands_count': 0,
                'points_earned_hour': 0,
                'points_earned_day': 0,
                'last_command_time': 0,
                'command_intervals': []
            }

        tracking = user_data['activity_tracking']

        # Reset counters co godzinÄ™
        if now - tracking.get('last_reset', 0) >= 3600:
            tracking['points_earned_hour'] = 0
            tracking['commands_count'] = 0
            tracking['last_reset'] = now
            tracking['command_intervals'] = []

        # Reset counters codziennie
        if now - tracking.get('daily_reset', 0) >= 86400:
            tracking['points_earned_day'] = 0
            tracking['daily_reset'] = now

        # SprawdÅº interwaÅ‚y miÄ™dzy komendami (anti-spam)
        if tracking['last_command_time'] > 0:
            interval = now - tracking['last_command_time']
            if interval < 2:  # Minimalno 2 sekundy miÄ™dzy komendami
                return False, "â° Zwolnij! Minimalno 2 sekundy miÄ™dzy komendami."

        # Dodaj interwaÅ‚ do listy (ostatnie 10)
        if len(tracking['command_intervals']) >= 10:
            tracking['command_intervals'].pop(0)
        tracking['command_intervals'].append(now - tracking.get('last_command_time', now))

        # SprawdÅº czy Å›redni interwaÅ‚ nie jest podejrzanie krÃ³tki
        if len(tracking['command_intervals']) >= 5:
            avg_interval = sum(tracking['command_intervals']) / len(tracking['command_intervals'])
            if avg_interval < 3:  # Åšrednio mniej niÅ¼ 3 sekundy = podejrzane
                return False, "ğŸ¤– Wykryto podejrzanÄ… aktywnoÅ›Ä‡! Zwolnij z komendami."

        # SprawdÅº limity
        if tracking['commands_count'] >= USER_ACTIVITY_LIMITS['commands_per_minute']:
            return False, f"â±ï¸ Limit {USER_ACTIVITY_LIMITS['commands_per_minute']} komend/minutÄ™ przekroczony!"

        if tracking['points_earned_hour'] >= USER_ACTIVITY_LIMITS['points_per_hour']:
            return False, f"ğŸ’ Limit {USER_ACTIVITY_LIMITS['points_per_hour']} punktÃ³w/godzinÄ™ przekroczony!"

        if tracking['points_earned_day'] >= USER_ACTIVITY_LIMITS['daily_limit']:
            return False, f"ğŸ“… Dzienny limit {USER_ACTIVITY_LIMITS['daily_limit']} punktÃ³w przekroczony!"

        # Aktualizuj countery
        tracking['commands_count'] += 1
        tracking['last_command_time'] = now

        update_user_data(user_id, user_data)
        return True, "OK"

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w rate_limit: {e}")
        return True, "OK"  # W razie bÅ‚Ä™du, pozwÃ³l kontynuowaÄ‡

def add_points_with_limit(user_id, points):
    """Dodaje punkty z sprawdzeniem limitÃ³w"""
    try:
        user_data = get_user_data_full(user_id)
        tracking = user_data.get('activity_tracking', {})

        # SprawdÅº czy nie przekroczy limitÃ³w
        hourly_points = tracking.get('points_earned_hour', 0) + points
        daily_points = tracking.get('points_earned_day', 0) + points

        if hourly_points > USER_ACTIVITY_LIMITS['points_per_hour']:
            return get_user_points(user_id), False  # Nie dodawaj punktÃ³w

        if daily_points > USER_ACTIVITY_LIMITS['daily_limit']:
            return get_user_points(user_id), False  # Nie dodawaj punktÃ³w

        # Dodaj punkty i aktualizuj tracking
        final_points = add_points(user_id, points)

        user_data = get_user_data_full(user_id)
        if 'activity_tracking' not in user_data:
            user_data['activity_tracking'] = {}

        user_data['activity_tracking']['points_earned_hour'] = hourly_points
        user_data['activity_tracking']['points_earned_day'] = daily_points
        update_user_data(user_id, user_data)

        return final_points, True

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w add_points_with_limit: {e}")
        return add_points(user_id, points), True

def load_user_data():
    """Ultraodporne Å‚adowanie danych"""
    try:
        if os.path.exists(USER_DATA_FILE):
            with open(USER_DATA_FILE, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                if content:
                    data = json.loads(content)
                    # SprawdÅº czy dane sÄ… poprawne
                    if isinstance(data, dict):
                        return data
                    else:
                        logging.warning("NieprawidÅ‚owy format danych - resetujÄ™")
                        return {}
    except json.JSONDecodeError:
        logging.warning("Uszkodzony JSON - tworzÄ™ nowe dane")
        # Backup uszkodzonego pliku
        if os.path.exists(USER_DATA_FILE):
            try:
                backup_name = f"{USER_DATA_FILE}.backup.{int(time.time())}"
                os.rename(USER_DATA_FILE, backup_name)
                logging.info(f"Backup utworzony: {backup_name}")
            except:
                pass
    except Exception as e:
        logging.warning(f"BÅ‚Ä…d Å‚adowania: {e} - uÅ¼ywam pustych danych")

    return {}

def save_user_data(data):
    """Ultraodporny zapis danych z wieloma zabezpieczeniami"""
    try:
        # SprawdÅº czy dane sÄ… poprawne
        if not isinstance(data, dict):
            logging.error("NieprawidÅ‚owe dane do zapisu - pomijam")
            return

        # Zapisz do tymczasowego pliku z retry
        for attempt in range(3):
            try:
                temp_file = f"{USER_DATA_FILE}.tmp.{attempt}"
                with open(temp_file, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)

                # SprawdÅº czy plik siÄ™ zapisaÅ‚ poprawnie
                with open(temp_file, 'r', encoding='utf-8') as f:
                    test_data = json.load(f)
                    if isinstance(test_data, dict):
                        # Atomowe przeniesienie
                        os.replace(temp_file, USER_DATA_FILE)
                        return

            except Exception as e:
                logging.warning(f"PrÃ³ba zapisu {attempt+1}/3 nieudana: {e}")
                if attempt == 2:
                    logging.error("Wszystkie prÃ³by zapisu nieudane!")
                else:
                    time.sleep(0.1)  # KrÃ³tka przerwa przed kolejnÄ… prÃ³bÄ…

    except Exception as e:
        logging.error(f"Krytyczny bÅ‚Ä…d zapisu: {e}")

def get_user_points(user_id):
    data = load_user_data()
    return data.get(str(user_id), {}).get('points', 0)

def add_points(user_id, points):
    data = load_user_data()
    if str(user_id) not in data:
        data[str(user_id)] = {
            'points': 0, 'badges': [], 'quiz_streak': 0, 'last_daily': None,
            'pet_level': 1, 'pet_happiness': 50, 'battle_wins': 0, 'mining_level': 1,
            'mafia_rank': 'Nowicjusz', 'mafia_respect': 0, 'last_heist': 0, 'protection_money': 0,
            'territory_owned': 0, 'last_mission': 0, 'contracts_completed': 0,
            'blackjack_wins': 0, 'poker_wins': 0, 'dice_wins': 0
        }
    data[str(user_id)]['points'] += points
    save_user_data(data)
    return data[str(user_id)]['points']

def get_user_data_full(user_id):
    data = load_user_data()
    return data.get(str(user_id), {
        'points': 0, 'badges': [], 'quiz_streak': 0, 'last_daily': None,
        'pet_level': 1, 'pet_happiness': 50, 'battle_wins': 0, 'mining_level': 1,
        'mafia_rank': 'Nowicjusz', 'mafia_respect': 0, 'last_heist': 0, 'protection_money': 0,
        'territory_owned': 0, 'last_mission': 0, 'contracts_completed': 0,
        'blackjack_wins': 0, 'poker_wins': 0, 'dice_wins': 0,
        'recruited_by': None, 'recruited_members': [], 'last_recruitment': 0,
        'chat_channels': ['rodzina'], 'last_message': 0, 'message_count': 0,
        'loyalty_bonus': 0, 'special_missions': [], 'special_buildings': [],
        'rare_minerals_found': {}, 'city_level': 0, 'last_mine_kopalnia_podstawowa': 0,
        'last_mine_kopalnia_glleboka': 0, 'last_mine_kopalnia_diamentowa': 0,
        'last_mine_kopalnia_magiczna': 0, 'last_mine_kopalnia_kosmiczna': 0
    })

def update_user_data(user_id, updates):
    data = load_user_data()
    if str(user_id) not in data:
        data[str(user_id)] = {
            'points': 0, 'badges': [], 'quiz_streak': 0, 'last_daily': None,
            'pet_level': 1, 'pet_happiness': 50, 'battle_wins': 0, 'mining_level': 1,
            'mafia_rank': 'Nowicjusz', 'mafia_respect': 0, 'last_heist': 0, 'protection_money': 0,
            'territory_owned': 0, 'last_mission': 0, 'contracts_completed': 0,
            'blackjack_wins': 0, 'poker_wins': 0, 'dice_wins': 0,
            'recruited_by': None, 'recruited_members': [], 'last_recruitment': 0,
            'chat_channels': ['rodzina'], 'last_message': 0, 'message_count': 0,
            'loyalty_bonus': 0, 'special_missions': []
        }
    data[str(user_id)].update(updates)
    save_user_data(data)

# === KEEP-ALIVE SERVER ===
async def health_check(request):
    return web.Response(text="Bot is alive!")

def start_keepalive():
    """Uruchamia keep-alive serwer"""
    try:
        app = web.Application()
        app.router.add_get("/", health_check)
        app.router.add_get("/health", health_check)
        web.run_app(app, host="0.0.0.0", port=8080)
    except Exception as e:
        logging.error(f"Keep-alive server error: {e}")

# === WATCHDOG ===
async def watchdog():
    """Watchdog monitorujÄ…cy stan bota"""
    count = 0
    while True:
        count += 1
        logging.info(f"ğŸ„ Watchdog #{count} - Bot alive at {time.strftime('%H:%M:%S')}")
        await asyncio.sleep(120)  # Co 2 minuty

# === SYSTEM MAFII ===
MAFIA_RANKS = {
    'Nowicjusz': {'min_respect': 0, 'max_respect': 99, 'bonus': 0},
    'Å»oÅ‚nierz': {'min_respect': 100, 'max_respect': 299, 'bonus': 5},
    'Capo': {'min_respect': 300, 'max_respect': 599, 'bonus': 10},
    'Underboss': {'min_respect': 600, 'max_respect': 999, 'bonus': 20},
    'Don': {'min_respect': 1000, 'max_respect': float('inf'), 'bonus': 50}
}

# === MAFIA BOSSES & HIERARCHY ===
MAFIA_BOSSES = {
    'don_mleko': {
        'name': 'ğŸ„ Don Mleko',
        'title': 'Ojciec rodziny',
        'respect': 999999,
        'description': 'Legendarny boss wszystkich bossÃ³w. Jego mleko daje Å¼ycie caÅ‚ej rodzinie.',
        'special_power': 'MoÅ¼e daÄ‡ kaÅ¼demu bÅ‚ogosÅ‚awieÅ„stwo +100% do wszystkich nagrÃ³d'
    },
    'bialy_rogacz': {
        'name': 'ğŸ¤µğŸ‚ BiaÅ‚y Rogacz',
        'title': 'Prawa rÄ™ka Dona',
        'respect': 50000,
        'description': 'PotÄ™Å¼ny biaÅ‚y byk w eleganckim garniturze. Prawa rÄ™ka Don Mleko i jego najbardziej zaufany doradca.',
        'special_power': 'MoÅ¼e werbowaÄ‡ nowych czÅ‚onkÃ³w i dawaÄ‡ specjalne misje'
    },
    'krwawa_krowa': {
        'name': 'ğŸ©¸ğŸ„ Krwawa Krowa',
        'title': 'Egzekutor rodziny',
        'respect': 25000,
        'description': 'Bezlitosny egzekutor, ktÃ³ry zaÅ‚atwia "problemy" rodziny.',
        'special_power': 'MoÅ¼e rozpoczynaÄ‡ wojny miÄ™dzy rodzinami'
    },
    'mleczny_phantom': {
        'name': 'ğŸ‘» Milk Phantom',
        'title': 'Szpieg rodziny',
        'respect': 20000,
        'description': 'Niewidzialny szpieg, ktÃ³ry zbiera informacje o wrogach.',
        'special_power': 'MoÅ¼e sprawdzaÄ‡ statystyki innych graczy'
    }
}

# === SYSTEM KOMUNIKACJI ===
CHAT_CHANNELS = {
    'rodzina': {'name': 'ğŸ‘¥ KanaÅ‚ Rodziny', 'min_respect': 0, 'description': 'GÅ‚Ã³wny kanaÅ‚ dla wszystkich czÅ‚onkÃ³w'},
    'capo': {'name': 'ğŸ‘” KanaÅ‚ Capo', 'min_respect': 300, 'description': 'Tylko dla Capo i wyÅ¼ej'},
    'underboss': {'name': 'ğŸ¤µ KanaÅ‚ Underboss', 'min_respect': 600, 'description': 'Tylko dla Underboss i DonÃ³w'},
    'don': {'name': 'ğŸ‘‘ KanaÅ‚ DonÃ³w', 'min_respect': 1000, 'description': 'Sekretny kanaÅ‚ najwyÅ¼szych rangÄ…'},
    'tajny': {'name': 'ğŸ”’ Tajny KanaÅ‚', 'min_respect': 500, 'description': 'KanaÅ‚ dla zaufanych czÅ‚onkÃ³w'}
}

# === SYSTEM GILDII ===
GUILDS_FILE = "guilds_data.json"
GUILD_LEVELS = {
    1: {'members_required': 3, 'bonus': 10, 'name': 'PoczÄ…tkujÄ…ca Rodzina'},
    2: {'members_required': 5, 'bonus': 20, 'name': 'RosnÄ…ca Rodzina'},
    3: {'members_required': 8, 'bonus': 35, 'name': 'Silna Rodzina'},
    4: {'members_required': 12, 'bonus': 50, 'name': 'PotÄ™Å¼na Rodzina'},
    5: {'members_required': 20, 'bonus': 75, 'name': 'Legenda Mafii'},
    6: {'members_required': 30, 'bonus': 100, 'name': 'Imperium Don Mleko'}
}

GUILD_MISSIONS = [
    {
        'name': 'Grupowy Napad',
        'description': 'Skoordynowany napad na bank - wymaga 3+ czÅ‚onkÃ³w',
        'min_members': 3,
        'difficulty': 'Å›redni',
        'reward_per_member': (100, 200),
        'guild_experience': 50,
        'cooldown': 7200  # 2 godziny
    },
    {
        'name': 'Wojna GangÃ³w',
        'description': 'Pokonajcie wrogÄ… gildiÄ™ - wymaga 5+ czÅ‚onkÃ³w',
        'min_members': 5,
        'difficulty': 'trudny',
        'reward_per_member': (150, 300),
        'guild_experience': 100,
        'cooldown': 14400  # 4 godziny
    },
    {
        'name': 'PrzejÄ™cie Miasta',
        'description': 'ZdobÄ…dÅºcie kontrolÄ™ nad miastem - wymaga 8+ czÅ‚onkÃ³w',
        'min_members': 8,
        'difficulty': 'bardzo trudny',
        'reward_per_member': (250, 500),
        'guild_experience': 200,
        'cooldown': 28800  # 8 godzin
    },
    {
        'name': 'Kosmiczna Ekspedycja',
        'description': 'Podbijcie kosmos dla Don Mleko - wymaga 10+ czÅ‚onkÃ³w',
        'min_members': 10,
        'difficulty': 'legendarna',
        'reward_per_member': (500, 1000),
        'guild_experience': 500,
        'cooldown': 86400  # 24 godziny
    }
]

# === SYSTEM POLUBIEÅƒ I KOMENTARZY ===
POST_TYPES = {
    'achievement': 'ğŸ† OsiÄ…gniÄ™cie',
    'victory': 'âš”ï¸ ZwyciÄ™stwo',
    'jackpot': 'ğŸ’° Jackpot',
    'milestone': 'ğŸ¯ KamieÅ„ milowy',
    'funny': 'ğŸ˜‚ Zabawne',
    'help': 'â“ Pomoc',
    'announcement': 'ğŸ“¢ OgÅ‚oszenie'
}

FEED_POSTS_FILE = "social_feed.json"
COMMENTS_FILE = "post_comments.json"
LIKES_FILE = "post_likes.json"

MEMY = [
    "ğŸ„ Don Mleko patrzy... ZAWSZE patrzy! ğŸ‘€",
    "ğŸ’ HODL jak Don Mleko hodluje mleko! ğŸ¥›",
    "ğŸš€ Do ksiÄ™Å¼yca z Don Mleko! Ale czy ksiÄ™Å¼yc jest gotowy? ğŸŒ™",
    "ğŸ„ Kiedy ktoÅ› sprzedaje DMT:\n'Zdrajca w rodzinie!' - Don Mleko",
    "ğŸ’° Don Mleko: 'PieniÄ…dze nie Å›piÄ…, ja teÅ¼ nie!' ğŸ˜´",
    "ğŸ”¥ DMT > Bitcoin?\nDon Mleko: 'OczywiÅ›cie!' ğŸ’ª",
    "ğŸ„ Rodzina Don Mleko nie zapomina!\nAni nie wybacza... papierowym rÄ™kom! ğŸ“„âœ‹",
    "ğŸ¯ Don Mleko celuje w Mars!\nKsiÄ™Å¼yc to tylko przystanek! ğŸš€",
    "ğŸ¥› Kto nie pije mleka, ten nie zna prawdy! ğŸ„",
    "ğŸ’ Paper hands detected! Don Mleko disappointed! ğŸ˜¤"
]

GIFY = [
    "https://media.giphy.com/media/3o6ZtrbzjGAAXyx2WQ/giphy.gif",
    "https://media.giphy.com/media/mb410b43HO7aU/giphy.gif",
    "https://media.giphy.com/media/Ogak8XuKHLs6PYcqlp/giphy.gif",
    "https://media.giphy.com/media/12QMHpHsOBwQHS/giphy.gif",
    "https://media.giphy.com/media/YN1eB6slBDeNHr1gjs/giphy.gif",
    "https://media.giphy.com/media/3o84sq21TxDH6PyYms/giphy.gif",
    "https://media.giphy.com/media/l41YfykEffZ7QM55m/giphy.gif",
    "https://media.giphy.com/media/XreQmk7ETCak0/giphy.gif",
    "https://media.giphy.com/media/cJL1Y7MY1akc8/giphy.gif",
    "https://media.giphy.com/media/5fBH6zlg2vAokrF4kg/giphy.gif"
]

MISSIONS = [
    {
        'name': 'Windykacja dÅ‚ugÃ³w',
        'description': 'Odzyskaj pieniÄ…dze od dÅ‚uÅ¼nikÃ³w',
        'difficulty': 'Å‚atwy',
        'reward': (10, 20),
        'respect': 10,
        'time_required': 300  # 5 minut
    },
    {
        'name': 'Ochrona biznesu',
        'description': 'Zapewnij ochronÄ™ sklepowi',
        'difficulty': 'Å›redni',
        'reward': (20, 40),
        'respect': 20,
        'time_required': 600  # 10 minut
    },
    {
        'name': 'Przemyt cigaret',
        'description': 'Przeszmugluj kontrabandÄ™ przez granicÄ™',
        'difficulty': 'Å›redni',
        'reward': (30, 50),
        'respect': 25,
        'time_required': 900  # 15 minut
    },
    {
        'name': 'KradzieÅ¼ aut',
        'description': 'UkraÅ›Ä‡ luksusowe samochody dla kolekcjonera',
        'difficulty': 'trudny',
        'reward': (40, 70),
        'respect': 30,
        'time_required': 1200  # 20 minut
    },
    {
        'name': 'Napad na bank',
        'description': 'Ryzykowny napad z wielkÄ… nagrodÄ…',
        'difficulty': 'trudny',
        'reward': (60, 100),
        'respect': 50,
        'time_required': 1800  # 30 minut
    },
    {
        'name': 'Handel narkotykami',
        'description': 'Sprzedaj DMT na ulicach miasta',
        'difficulty': 'trudny',
        'reward': (80, 120),
        'respect': 60,
        'time_required': 2100  # 35 minut
    },
    {
        'name': 'Handel broniÄ…',
        'description': 'Nielegalna sprzedaÅ¼ broni',
        'difficulty': 'bardzo trudny',
        'reward': (100, 200),
        'respect': 100,
        'time_required': 3600  # 1 godzina
    },
    {
        'name': 'PrzejÄ™cie terenu',
        'description': 'WypÄ™dÅº konkurencyjnÄ… rodzinÄ™ z dzielnicy',
        'difficulty': 'bardzo trudny',
        'reward': (150, 240),
        'respect': 120,
        'time_required': 4500  # 1.25h
    },
    {
        'name': 'ZabÃ³jstwo na zlecenie',
        'description': 'UsuÅ„ problematycznego Å›wiadka',
        'difficulty': 'ekspert',
        'reward': (160, 300),
        'respect': 150,
        'time_required': 5400  # 1.5h
    },
    {
        'name': 'Cyber atak na konkurencjÄ™',
        'description': 'Zhakuj systemy wrogich rodzin',
        'difficulty': 'ekspert',
        'reward': (200, 400),
        'respect': 200,
        'time_required': 7200  # 2 godziny
    },
    {
        'name': 'PrzejÄ™cie kasyna',
        'description': 'Przejmij kontrolÄ™ nad najwiÄ™kszym kasynem w mieÅ›cie',
        'difficulty': 'legendarna',
        'reward': (300, 600),
        'respect': 300,
        'time_required': 10800  # 3h
    },
    {
        'name': 'Kosmiczna misja DMT',
        'description': 'Przemycaj DMT przez galaktykÄ™',
        'difficulty': 'legendarna',
        'reward': (400, 1000),
        'respect': 500,
        'time_required': 14400  # 4 godziny
    },
    {
        'name': 'Infiltracja FBI',
        'description': 'Wkradnij siÄ™ do siedziby FBI i zniszcz dowody',
        'difficulty': 'mityczna',
        'reward': (1000, 2000),
        'respect': 1000,
        'time_required': 21600  # 6 godzin
    },
    {
        'name': 'Kontrola nad miastem',
        'description': 'ZostaÅ„ nieoficjalnym wÅ‚adcÄ… miasta',
        'difficulty': 'mityczna',
        'reward': (1500, 3000),
        'respect': 1500,
        'time_required': 28800  # 8h
    },
    {
        'name': 'PrzejÄ™cie kontroli nad internetem',
        'description': 'ZostaÅ„ wÅ‚adcÄ… cyfrowego Å›wiata',
        'difficulty': 'boski',
        'reward': (2000, 5000),
        'respect': 2500,
        'time_required': 43200  # 12 godzin
    },
    {
        'name': 'Imperium Don Mleko',
        'description': 'Zbuduj globalne imperium mleczne',
        'difficulty': 'transcendentny',
        'reward': (4000, 10000),
        'respect': 5000,
        'time_required': 86400  # 24h
    },
]

# === ROZBUDOWANE MIASTO ===
TERRITORIES = [
    {'name': 'Dzielnica przemysÅ‚owa', 'cost': 500, 'income': 2, 'type': 'przemysÅ‚'},
    {'name': 'Osiedle mieszkaniowe', 'cost': 800, 'income': 4, 'type': 'mieszkania'},
    {'name': 'Centrum handlowe', 'cost': 1000, 'income': 5, 'type': 'handel'},
    {'name': 'Dzielnica klubÃ³w', 'cost': 1500, 'income': 8, 'type': 'rozrywka'},
    {'name': 'Port', 'cost': 2000, 'income': 10, 'type': 'transport'},
    {'name': 'Dzielnica luksusowa', 'cost': 3000, 'income': 15, 'type': 'luksus'},
    {'name': 'Lotnisko', 'cost': 4000, 'income': 20, 'type': 'transport'},
    {'name': 'Kasyno', 'cost': 5000, 'income': 30, 'type': 'rozrywka'},
    {'name': 'Uniwersytet', 'cost': 6000, 'income': 25, 'type': 'edukacja'},
    {'name': 'Bank miejski', 'cost': 7500, 'income': 40, 'type': 'finanse'},
    {'name': 'Szpital', 'cost': 9000, 'income': 35, 'type': 'medycyna'},
    {'name': 'Dzielnica biznesowa', 'cost': 12000, 'income': 60, 'type': 'biznes'},
    {'name': 'Rafineria mleka', 'cost': 15000, 'income': 80, 'type': 'przemysÅ‚'},
    {'name': 'Dzielnica dyplomatyczna', 'cost': 18000, 'income': 90, 'type': 'polityka'},
    {'name': 'Imperium medialne', 'cost': 20000, 'income': 100, 'type': 'media'},
    {'name': 'Wojskowa baza', 'cost': 25000, 'income': 120, 'type': 'wojsko'},
    {'name': 'Centrum technologiczne', 'cost': 30000, 'income': 150, 'type': 'tech'},
    {'name': 'Stolica regionu', 'cost': 40000, 'income': 200, 'type': 'region'},
    {'name': 'CaÅ‚e miasto', 'cost': 50000, 'income': 250, 'type': 'metropolia'},
    {'name': 'CaÅ‚e paÅ„stwo', 'cost': 100000, 'income': 500, 'type': 'kraj'},
    # 10 NOWYCH TERYTORII
    {'name': 'Kosmiczny port', 'cost': 150000, 'income': 600, 'type': 'kosmos'},
    {'name': 'Fabryka robotÃ³w', 'cost': 200000, 'income': 750, 'type': 'technologia'},
    {'name': 'Wyspy tropikalne', 'cost': 250000, 'income': 800, 'type': 'turystyka'},
    {'name': 'Podwodne miasto', 'cost': 300000, 'income': 900, 'type': 'futurystyka'},
    {'name': 'Centrum AI', 'cost': 400000, 'income': 1000, 'type': 'sztuczna_inteligencja'},
    {'name': 'Stacja orbitalna', 'cost': 500000, 'income': 1200, 'type': 'orbita'},
    {'name': 'Kolonia ksiÄ™Å¼ycowa', 'cost': 750000, 'income': 1500, 'type': 'ksiÄ™Å¼yc'},
    {'name': 'Baza na Marsie', 'cost': 1000000, 'income': 2000, 'type': 'mars'},
    {'name': 'Imperium galaktyczne', 'cost': 2000000, 'income': 3000, 'type': 'galaktyka'},
    {'name': 'WÅ‚adza nad wszechÅ›wiatem', 'cost': 5000000, 'income': 5000, 'type': 'uniwersum'}
]

# === NOWE BUDYNKI SPECJALNE ===
SPECIAL_BUILDINGS = {
    'mleczarnia': {
        'name': 'ğŸ¥› Mleczarnia Don Mleko',
        'cost': 3000,
        'description': 'Produkuje specjalne mleko zwiÄ™kszajÄ…ce mining o 25%',
        'bonus_type': 'mining_boost',
        'bonus_value': 25,
        'income': 50
    },
    'laboratorium': {
        'name': 'ğŸ§ª Laboratorium DMT',
        'cost': 8000,
        'description': 'ZwiÄ™ksza szanse na rzadkie mineraÅ‚y o 50%',
        'bonus_type': 'rare_minerals',
        'bonus_value': 50,
        'income': 0
    },
    'akademia': {
        'name': 'ğŸ“ Akademia Mafii',
        'cost': 6000,
        'description': 'ZwiÄ™ksza zdobywanie szacunku o 30%',
        'bonus_type': 'respect_boost',
        'bonus_value': 30,
        'income': 0
    },
    'skarbiec': {
        'name': 'ğŸ¦ Skarbiec Rodziny',
        'cost': 10000,
        'description': 'Chroni 50% punktÃ³w przed stratÄ… w napadach',
        'bonus_type': 'protection',
        'bonus_value': 50,
        'income': 0
    },
    'fabryka_botow': {
        'name': 'ğŸ¤– Fabryka BotÃ³w',
        'cost': 25000,
        'description': 'Automatycznie wykonuje mining co 30 min',
        'bonus_type': 'auto_mining',
        'bonus_value': 30,
        'income': 0
    },
    'cyber_centrum': {
        'name': 'ğŸ’» Cyber Centrum',
        'cost': 35000,
        'description': 'Hackuje konkurencyjne kopalnie - zwiÄ™ksza wszystkie nagrody o 40%',
        'bonus_type': 'all_rewards_boost',
        'bonus_value': 40,
        'income': 200
    },
    'krypto_farma': {
        'name': 'âš¡ Krypto Farma',
        'cost': 50000,
        'description': 'Mineuje DMT automatycznie - pasywny dochÃ³d 500 DMT/h',
        'bonus_type': 'passive_mining',
        'bonus_value': 500,
        'income': 500
    },
    'casino_royale': {
        'name': 'ğŸ° Casino Royale',
        'cost': 75000,
        'description': 'ZwiÄ™ksza wygrane w grach o 100% i daje VIP bonusy',
        'bonus_type': 'gambling_boost',
        'bonus_value': 100,
        'income': 800
    },
    'rakieta_don_mleko': {
        'name': 'ğŸš€ Rakieta Don Mleko',
        'cost': 100000,
        'description': 'MEGA BOOST! Wszystkie aktywnoÅ›ci x2, dostÄ™p do kosmicznych misji',
        'bonus_type': 'mega_boost',
        'bonus_value': 200,
        'income': 1500
    },
    'portal_czasowy': {
        'name': 'ğŸŒ€ Portal Czasowy',
        'cost': 150000,
        'description': 'Redukuje wszystkie cooldown\'y o 75% - szybsze dziaÅ‚anie!',
        'bonus_type': 'time_boost',
        'bonus_value': 75,
        'income': 2000
    },
    'forteca_mleka': {
        'name': 'ğŸ° Forteca Mleka',
        'cost': 200000,
        'description': 'ULTIMATE DEFENSE! 90% ochrona + 3000 DMT/h dochÃ³d',
        'bonus_type': 'ultimate_protection',
        'bonus_value': 90,
        'income': 3000
    },
    'fabryka_memow': {
        'name': 'ğŸ˜‚ Fabryka MemÃ³w',
        'cost': 30000,
        'description': 'Generuje losowe bonusy i easter eggi - nigdy nie wiesz co dostaniesz!',
        'bonus_type': 'random_bonus',
        'bonus_value': 50,
        'income': 300
    },
    'centrum_dowodzenia': {
        'name': 'ğŸ¯ Centrum Dowodzenia',
        'cost': 80000,
        'description': 'Koordynuje wszystkie operacje - bonus do wszystkich dziaÅ‚aÅ„ +60%',
        'bonus_type': 'coordination_boost',
        'bonus_value': 60,
        'income': 600
    }
}

# === ROZSZERZONE MINING ===
MINING_LOCATIONS = {
    'kopalnia_podstawowa': {
        'name': 'â›ï¸ Kopalnia Podstawowa',
        'unlock_level': 1,
        'success_rate': 70,
        'base_reward': (1, 5),
        'cooldown': 300,  # 5 minut
        'rare_chance': 0,
        'description': 'Podstawowa kopalnia dla poczÄ…tkujÄ…cych'
    },
    'kopalnia_glleboka': {
        'name': 'ğŸ•³ï¸ Kopalnia GÅ‚Ä™boka',
        'unlock_level': 5,
        'success_rate': 60,
        'base_reward': (3, 10),
        'cooldown': 600,  # 10 minut
        'rare_chance': 5,
        'description': 'GÅ‚Ä™bsza kopalnia z lepszymi nagrodami'
    },
    'kopalnia_diamentowa': {
        'name': 'ğŸ’ Kopalnia Diamentowa',
        'unlock_level': 10,
        'success_rate': 50,
        'base_reward': (5, 20),
        'cooldown': 900,  # 15 minut
        'rare_chance': 10,
        'description': 'Kopalnia z diamentami i klejnotami'
    },
    'kopalnia_magiczna': {
        'name': 'ğŸŒŸ Kopalnia Magiczna',
        'unlock_level': 15,
        'success_rate': 40,
        'base_reward': (10, 50),
        'cooldown': 1200,  # 20 minut
        'rare_chance': 15,
        'description': 'Magiczna kopalnia z legendarnymi mineraÅ‚ami'
    },
    'kopalnia_kosmiczna': {
        'name': 'ğŸš€ Kopalnia Kosmiczna',
        'unlock_level': 20,
        'success_rate': 30,
        'base_reward': (20, 100),
        'cooldown': 1800,  # 30 minut
        'rare_chance': 25,
        'description': 'Kosmiczna kopalnia z meteorytem DMT'
    }
}

RARE_MINERALS = {
    'krysztal_mleka': {
        'name': 'ğŸ”® KrysztaÅ‚ Mleka',
        'value': 100,
        'chance': 5,
        'description': 'Rzadki krysztaÅ‚ peÅ‚en mocy Don Mleko'
    },
    'diament_dmt': {
        'name': 'ğŸ’  Diament DMT',
        'value': 250,
        'chance': 3,
        'description': 'Legendarny diament z czystego DMT'
    },
    'meteoryt_kosmiczny': {
        'name': 'â˜„ï¸ Meteoryt Kosmiczny',
        'value': 500,
        'chance': 1,
        'description': 'Meteoryt z kosmosu peÅ‚en tajemniczej energii'
    },
    'esencja_dona': {
        'name': 'ğŸŒŸ Esencja Dona',
        'value': 1000,
        'chance': 0.5,
        'description': 'Najrzadsza esencja zawierajÄ…ca moc samego Don Mleko'
    },
    'neutronium_dmt': {
        'name': 'âš›ï¸ Neutronium DMT',
        'value': 2000,
        'chance': 0.3,
        'description': 'Ultra rzadki mineral z jÄ…dra neutronowej gwiazdy'
    },
    'czasoprzestrzen_krysztal': {
        'name': 'ğŸŒŒ KrysztaÅ‚ Czasoprzestrzeni',
        'value': 5000,
        'chance': 0.1,
        'description': 'KrysztaÅ‚ Å‚amiÄ…cy prawa fizyki - daje bonusy czasowe'
    },
    'mleko_boskie': {
        'name': 'ğŸ¥›âœ¨ Mleko Boskie',
        'value': 10000,
        'chance': 0.05,
        'description': 'Legendarne mleko z najwyÅ¼szych sfer - ultimate power!'
    },
    'rdzen_uniwersum': {
        'name': 'ğŸŒ  RdzeÅ„ Uniwersum',
        'value': 25000,
        'chance': 0.01,
        'description': 'Fragment z poczÄ…tku czasÃ³w - nieskoÅ„czona moc!'
    },
    'dna_don_mleko': {
        'name': 'ğŸ§¬ DNA Don Mleko',
        'value': 50000,
        'chance': 0.005,
        'description': 'Genetyczny materiaÅ‚ samego Don Mleko - ultimate evolution!'
    }
}

BADGES = {
    "newbie": {"name": "ğŸ„ Nowy w rodzinie", "desc": "Pierwsze kroki z Don Mleko"},
    "active": {"name": "âš¡ Aktywny czÅ‚onek", "desc": "50+ punktÃ³w"},
    "quiz_master": {"name": "ğŸ§  Mistrz quizÃ³w", "desc": "10 poprawnych odpowiedzi"},
    "hodler": {"name": "ğŸ’ Diamond Hands", "desc": "100+ punktÃ³w"},
    "legend": {"name": "ğŸ‘‘ Legenda rodziny", "desc": "500+ punktÃ³w"},
    "daily_warrior": {"name": "â­ Wojownik codziennych zadaÅ„", "desc": "7 dni z rzÄ™du daily"},
    "pet_lover": {"name": "ğŸ• MiÅ‚oÅ›nik zwierzÄ…t", "desc": "Pet na poziomie 10"},
    "battle_champion": {"name": "âš”ï¸ Mistrz bitew", "desc": "10 wygranych bitew"},
    "miner": {"name": "â›ï¸ GÃ³rnik DMT", "desc": "Mining na poziomie 5"},
    "dmtb_finder": {"name": "ğŸŒŸ DMTB Finder", "desc": "WykopaÅ‚ legendarny DMTB! (1:1,000,000)"},
    "mafia_boss": {"name": "ğŸ¤µ Boss mafii", "desc": "OsiÄ…gniÄ™to rangÄ™ Don"},
    "heist_master": {"name": "ğŸ’° Mistrz napadÃ³w", "desc": "10 udanych napadÃ³w"},
    "territory_king": {"name": "ğŸ° KrÃ³l terytorium", "desc": "Posiada 3+ terytorium"},
    "gambler": {"name": "ğŸ° Hazardzista", "desc": "Wygraj w 3 rÃ³Å¼nych grach"},
    "contract_killer": {"name": "ğŸ”« ZabÃ³jca kontraktowy", "desc": "5 wykonanych kontraktÃ³w"},
    "recruiter": {"name": "ğŸ‘¥ Rekruter", "desc": "ZwerbowaÅ‚ 5 nowych czÅ‚onkÃ³w"},
    "social_butterfly": {"name": "ğŸ’¬ SpoÅ‚ecznoÅ›Ä‡", "desc": "WysÅ‚aÅ‚ 50 wiadomoÅ›ci na czacie"},
    "loyal_member": {"name": "ğŸ¤ Lojalny czÅ‚onek", "desc": "30 dni w rodzinie"},
    "don_mleko_blessed": {"name": "ğŸ„ BÅ‚ogosÅ‚awiony przez Dona", "desc": "Specjalne bÅ‚ogosÅ‚awieÅ„stwo od Don Mleko"},
    "guild_founder": {"name": "ğŸ›ï¸ ZaÅ‚oÅ¼yciel Gildii", "desc": "ZaÅ‚oÅ¼yÅ‚ wÅ‚asnÄ… gildiÄ™"},
    "guild_leader": {"name": "ğŸ‘‘ Lider Gildii", "desc": "Prowadzi silnÄ… gildiÄ™"},
    "guild_veteran": {"name": "ğŸ›¡ï¸ Weteran Gildii", "desc": "UczestniczyÅ‚ w 10+ misjach gildijnych"},
    "guild_master": {"name": "ğŸ† Mistrz Gildii", "desc": "DoprowadziÅ‚ gildiÄ™ do poziomu 5+"}
}

# === FUNKCJE MAFII ===

async def mafia_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        respect = user_data.get('mafia_respect', 0)
        rank = get_mafia_rank(respect)

        keyboard = [
            [InlineKeyboardButton("ğŸ¯ Misje", callback_data="missions")],
            [InlineKeyboardButton("ğŸ° Terytorium", callback_data="territory")],
            [InlineKeyboardButton("ğŸ’° Napad", callback_data="heist")],
            [InlineKeyboardButton("ğŸ›¡ï¸ Haracze", callback_data="protection")],
            [InlineKeyboardButton("ğŸ‘¥ Werbowanie", callback_data="recruitment"), InlineKeyboardButton("ğŸ’¬ Czat", callback_data="chat")],
            [InlineKeyboardButton("ğŸ² Gry Mafii", callback_data="mafia_games")],
            [InlineKeyboardButton("ğŸ‘‘ Bossowie", callback_data="bosses")],
            [InlineKeyboardButton("ğŸ“Š Status mafii", callback_data="mafia_status")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            f"ğŸ¤µ **RODZINA MAFII DON MLEKO**\n\n"
            f"ğŸ‘¤ Twoja ranga: **{rank}**\n"
            f"â­ Szacunek: {respect}\n"
            f"ğŸ’° Bonus za rangÄ™: +{MAFIA_RANKS[rank]['bonus']}%\n\n"
            f"ğŸ¯ Wybierz akcjÄ™:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w mafia_menu: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w menu mafii!")

def get_mafia_rank(respect):
    for rank, data in MAFIA_RANKS.items():
        if data['min_respect'] <= respect <= data['max_respect']:
            return rank
    return 'Nowicjusz'

async def missions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        last_mission = user_data.get('last_mission', 0)
        now = time.time()

        if now - last_mission < 1800:  # 30 minut cooldown
            remaining = int(1800 - (now - last_mission))
            await update.message.reply_text(f"â° NastÄ™pna misja za {remaining//60}m {remaining%60}s!")
            return

        if not context.args:
            missions_text = "ğŸ¯ **DOSTÄ˜PNE MISJE MAFII:**\n\n"
            for i, mission in enumerate(MISSIONS, 1):
                missions_text += (
                    f"{i}. **{mission['name']}** ({mission['difficulty']})\n"
                    f"   ğŸ“ {mission['description']}\n"
                    f"   ğŸ’° Nagroda: {mission['reward'][0]}-{mission['reward'][1]} DMT\n"
                    f"   â­ Szacunek: +{mission['respect']}\n"
                    f"   â±ï¸ Czas: {mission['time_required']//60} min\n\n"
                )
            missions_text += "UÅ¼yj: `/missions [numer]` aby wybraÄ‡ misjÄ™"
            await update.message.reply_text(missions_text, parse_mode='Markdown')
            return

        try:
            mission_id = int(context.args[0]) - 1
            if mission_id < 0 or mission_id >= len(MISSIONS):
                raise ValueError
        except ValueError:
            await update.message.reply_text("âŒ Podaj prawidÅ‚owy numer misji!")
            return

        mission = MISSIONS[mission_id]

        # SprawdÅº szanse powodzenia - ensure mafia_respect exists
        respect = user_data.get('mafia_respect', 0)
        if 'mafia_respect' not in user_data:
            user_data['mafia_respect'] = 0
            respect = 0

        rank = get_mafia_rank(respect)
        success_bonus = MAFIA_RANKS[rank]['bonus']

        base_chance = {
            'Å‚atwy': 80,
            'Å›redni': 60,
            'trudny': 40,
            'bardzo trudny': 20
        }

        success_chance = min(95, base_chance[mission['difficulty']] + success_bonus)
        result = random.randint(1, 100)

        if result <= success_chance:
            # Sukces!
            reward = random.randint(*mission['reward'])
            respect_gain = mission['respect']

            points = add_points(user_id, reward)

            # Ensure we have fresh data and proper initialization
            user_data = get_user_data_full(user_id)
            current_respect = user_data.get('mafia_respect', 0)
            user_data['mafia_respect'] = current_respect + respect_gain
            user_data['last_mission'] = now
            user_data['contracts_completed'] = user_data.get('contracts_completed', 0) + 1
            update_user_data(user_id, user_data)

            # SprawdÅº odznaki
            if user_data['contracts_completed'] >= 5:
                check_and_award_badge(user_id, "contract_killer")
            if new_rank == 'Don':
                check_and_award_badge(user_id, "mafia_boss")

            rank_text = f"\nğŸ‰ AWANS! Nowa ranga: **{new_rank}**!" if new_rank != old_rank else ""

            await update.message.reply_text(
                f"âœ… **MISJA UDANA!**\n\n"
                f"ğŸ¯ {mission['name']}\n"
                f"ğŸ’° Nagroda: +{reward} DMT\n"
                f"â­ Szacunek: +{respect_gain}\n"
                f"ğŸ’ ÅÄ…cznie punktÃ³w: {points}{rank_text}\n\n"
                f"ğŸ‘¤ Ranga: {new_rank} (szacunek: {user_data['mafia_respect']})"
            )
        else:
            # PoraÅ¼ka
            user_data['last_mission'] = now
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸ’€ **MISJA NIEUDANA!**\n\n"
                f"ğŸ¯ {mission['name']}\n"
                f"ğŸ˜µ ZostaÅ‚eÅ› przyÅ‚apany przez policjÄ™!\n"
                f"âš ï¸ Szansa powodzenia byÅ‚a: {success_chance}%\n\n"
                f"â° SprÃ³buj ponownie za 30 minut!"
            )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w missions: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w misjach!")

async def heist(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        last_heist = user_data.get('last_heist', 0)
        now = time.time()

        if now - last_heist < 3600:  # 1 godzina cooldown
            remaining = int(3600 - (now - last_heist))
            await update.message.reply_text(f"â° NastÄ™pny napad za {remaining//60}m {remaining%60}s!")
            return

        # Koszt napadu
        cost = 100
        if user_data.get('points', 0) < cost:
            await update.message.reply_text(f"âŒ Potrzebujesz {cost} DMT na przygotowanie napadu!")
            return

        add_points(user_id, -cost)

        # Szanse powodzenia
        respect = user_data.get('mafia_respect', 0)
        rank = get_mafia_rank(respect)
        base_chance = 30 + MAFIA_RANKS[rank]['bonus']

        if random.randint(1, 100) <= base_chance:
            # Udany napad!
            jackpot = random.randint(500, 2000)
            points = add_points(user_id, jackpot)

            heist_user_data = get_user_data_full(user_id)
            heist_user_data['last_heist'] = now
            heist_user_data['mafia_respect'] += 75
            heist_count = heist_user_data.get('heist_count', 0) + 1
            heist_user_data['heist_count'] = heist_count

            update_user_data(user_id, heist_user_data)

            if heist_count >= 10:
                check_and_award_badge(user_id, "heist_master")

            await update.message.reply_text(
                f"ğŸ’° **NAPAD UDANY!**\n\n"
                f"ğŸ¦ UkradÅ‚eÅ›: {jackpot} DMT!\n"
                f"â­ Szacunek: +75\n"
                f"ğŸ’ ÅÄ…cznie punktÃ³w: {points}\n"
                f"ğŸ¯ Udane napady: {heist_count}\n\n"
                f"ğŸš¨ Uwaga! Policja CiÄ™ szuka!"
            )
        else:
            # Nieudany napad
            user_data['last_heist'] = now
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸš¨ **NAPAD NIEUDANY!**\n\n"
                f"ğŸ‘® ZostaÅ‚eÅ› przyÅ‚apany przez policjÄ™!\n"
                f"ğŸ’¸ Stracone przygotowania: {cost} DMT\n"
                f"âš ï¸ Szansa byÅ‚a: {base_chance}%\n\n"
                f"â° NastÄ™pny napad za 1 godzinÄ™!"
            )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w heist: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w napadzie!")

# === NOWE MINI GRY ===

async def blackjack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        if not context.args:
            await update.message.reply_text(
                "ğŸƒ **BLACKJACK DON MLEKO**\n\n"
                "Cel: Uzyskaj 21 lub blisko 21, ale nie przekrocz!\n"
                "UÅ¼ycie: `/blackjack [stawka]`\n\n"
                "ğŸ¯ Minimalna stawka: 10 DMT\n"
                "ğŸ¯ Maksymalna stawka: 200 DMT"
            )
            return

        try:
            bet = int(context.args[0])
        except ValueError:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ liczbÄ…!")
            return

        if bet < 10 or bet > 200:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ miÄ™dzy 10 a 200 DMT!")
            return

        points = get_user_points(user_id)
        if points < bet:
            await update.message.reply_text("âŒ Nie masz wystarczajÄ…co DMT!")
            return

        add_points(user_id, -bet)

        # Gra
        deck = list(range(1, 14)) * 4  # 1-13, 4 kolory
        random.shuffle(deck)

        player_cards = [deck.pop(), deck.pop()]
        dealer_cards = [deck.pop(), deck.pop()]

        def card_value(cards):
            value = 0
            aces = 0
            for card in cards:
                if card > 10:
                    value += 10
                elif card == 1:
                    aces += 1
                    value += 11
                else:
                    value += card

            while value > 21 and aces > 0:
                value -= 10
                aces -= 1
            return value

        def card_name(card):
            names = {1: 'A', 11: 'J', 12: 'Q', 13: 'K'}
            return names.get(card, str(card))

        player_value = card_value(player_cards)
        dealer_value = card_value([dealer_cards[0]])  # Tylko pierwsza karta

        # SprawdÅº blackjack
        if player_value == 21:
            win = int(bet * 2.5)
            final_points = add_points(user_id, win)

            user_data = get_user_data_full(user_id)
            user_data['blackjack_wins'] = user_data.get('blackjack_wins', 0) + 1
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸƒ **BLACKJACK!** ğŸ‰\n\n"
                f"Twoje karty: {' '.join(card_name(c) for c in player_cards)} (21)\n"
                f"ğŸ’° Wygrana: {win} DMT (x2.5)\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )
            return

        # Dealer ma blackjack
        if card_value(dealer_cards) == 21:
            await update.message.reply_text(
                f"ğŸ’€ Dealer ma BLACKJACK!\n\n"
                f"Twoje karty: {' '.join(card_name(c) for c in player_cards)} ({player_value})\n"
                f"Dealer: {' '.join(card_name(c) for c in dealer_cards)} (21)\n"
                f"ğŸ’¸ PrzegraÅ‚eÅ›: {bet} DMT"
            )
            return

        # Normalna gra - dealer dobiera do 17
        dealer_full_value = card_value(dealer_cards)
        while dealer_full_value < 17:
            dealer_cards.append(deck.pop())
            dealer_full_value = card_value(dealer_cards)

        # SprawdÅº wynik
        if dealer_full_value > 21:
            # Dealer przekroczyÅ‚
            win = bet * 2
            final_points = add_points(user_id, win)
            result = "ğŸ‰ WYGRANA! Dealer przekroczyÅ‚ 21!"
        elif player_value > dealer_full_value:
            # Gracz wygrywa
            win = bet * 2
            final_points = add_points(user_id, win)
            result = "ğŸ‰ WYGRANA! WyÅ¼sza rÄ™ka!"
        elif player_value == dealer_full_value:
            # Remis
            final_points = add_points(user_id, bet)
            result = "ğŸ¤ REMIS! Zwrot stawki"
        else:
            # Dealer wygrywa
            final_points = get_user_points(user_id)
            result = "ğŸ’€ PRZEGRANA!"

        if 'win' in locals():
            user_data = get_user_data_full(user_id)
            user_data['blackjack_wins'] = user_data.get('blackjack_wins', 0) + 1
            update_user_data(user_id, user_data)

        await update.message.reply_text(
            f"ğŸƒ **BLACKJACK WYNIK**\n\n"
            f"Twoje karty: {' '.join(card_name(c) for c in player_cards)} ({player_value})\n"
            f"Dealer: {' '.join(card_name(c) for c in dealer_cards)} ({dealer_full_value})\n\n"
            f"{result}\n"
            f"ğŸ’ Masz teraz: {final_points} DMT"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w blackjack: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w blackjack!")

async def dice_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        if not context.args or len(context.args) != 2:
            await update.message.reply_text(
                "ğŸ² **GRA W KOÅšCI DON MLEKO**\n\n"
                "Zgadnij sumÄ™ dwÃ³ch koÅ›ci!\n"
                "UÅ¼ycie: `/dice [stawka] [suma]`\n\n"
                "ğŸ¯ Suma: 2-12\n"
                "ğŸ¯ Stawka: 5-100 DMT\n\n"
                "ğŸ’° WypÅ‚aty:\n"
                "â€¢ 7 (najczÄ™stsza): x4\n"
                "â€¢ 6,8: x5\n"
                "â€¢ 5,9: x6\n"
                "â€¢ 4,10: x8\n"
                "â€¢ 3,11: x10\n"
                "â€¢ 2,12 (najrzadsza): x15"
            )
            return

        try:
            bet = int(context.args[0])
            guess = int(context.args[1])
        except ValueError:
            await update.message.reply_text("âŒ Stawka i suma muszÄ… byÄ‡ liczbami!")
            return

        if bet < 5 or bet > 100:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ miÄ™dzy 5 a 100 DMT!")
            return

        if guess < 2 or guess > 12:
            await update.message.reply_text("âŒ Suma musi byÄ‡ miÄ™dzy 2 a 12!")
            return

        points = get_user_points(user_id)
        if points < bet:
            await update.message.reply_text("âŒ Nie masz wystarczajÄ…co DMT!")
            return

        add_points(user_id, -bet)

        # Rzut koÅ›Ä‡mi
        dice1 = random.randint(1, 6)
        dice2 = random.randint(1, 6)
        total = dice1 + dice2

        # WypÅ‚aty
        multipliers = {
            2: 15, 3: 10, 4: 8, 5: 6, 6: 5, 7: 4,
            8: 5, 9: 6, 10: 8, 11: 10, 12: 15
        }

        if total == guess:
            win = bet * multipliers[guess]
            final_points = add_points(user_id, win)

            user_data = get_user_data_full(user_id)
            user_data['dice_wins'] = user_data.get('dice_wins', 0) + 1
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸ² **TRAFIONE!** ğŸ‰\n\n"
                f"ğŸ¯ WypadÅ‚o: {dice1} + {dice2} = {total}\n"
                f"ğŸ’¡ Twoja prognoza: {guess}\n"
                f"ğŸ’° Wygrana: {win} DMT (x{multipliers[guess]})\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )
        else:
            final_points = get_user_points(user_id)
            await update.message.reply_text(
                f"ğŸ² **NIETRAFIONE!** ğŸ’€\n\n"
                f"ğŸ¯ WypadÅ‚o: {dice1} + {dice2} = {total}\n"
                f"ğŸ’¡ Twoja prognoza: {guess}\n"
                f"ğŸ’¸ Stracone: {bet} DMT\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w dice_game: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w grze w koÅ›ci!")

async def crash_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        if not context.args or len(context.args) != 2:
            await update.message.reply_text(
                "ğŸš€ **CRASH GAME DON MLEKO**\n\n"
                "Rakieta leci w gÃ³rÄ™! Kiedy siÄ™ zatrzyma?\n"
                "UÅ¼ycie: `/crash [stawka] [multiplier]`\n\n"
                "ğŸ¯ Stawka: 10-200 DMT\n"
                "ğŸ¯ Multiplier: 1.1x - 10.0x\n\n"
                "ğŸ“ˆ Im wyÅ¼szy multiplier, tym wiÄ™ksze ryzyko!\n"
                "ğŸŒ™ JeÅ›li rakieta doleci do Twojego multiplikatora,\n"
                "    wygrywasz stawkÄ™ x multiplier!"
            )
            return

        try:
            bet = int(context.args[0])
            target_multi = float(context.args[1])
        except ValueError:
            await update.message.reply_text("âŒ SprawdÅº format: [stawka] [multiplier]!")
            return

        if bet < 10 or bet > 200:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ miÄ™dzy 10 a 200 DMT!")
            return

        if target_multi < 1.1 or target_multi > 10.0:
            await update.message.reply_text("âŒ Multiplier musi byÄ‡ miÄ™dzy 1.1x a 10.0x!")
            return

        points = get_user_points(user_id)
        if points < bet:
            await update.message.reply_text("âŒ Nie masz wystarczajÄ…co DMT!")
            return

        add_points(user_id, -bet)

        # Symulacja crash
        crash_point = round(random.uniform(1.0, 15.0), 2)

        if crash_point >= target_multi:
            # Wygrana!
            win = int(bet * target_multi)
            final_points = add_points(user_id, win)

            await update.message.reply_text(
                f"ğŸš€ **RAKIETA DOTARÅA!** ğŸŒ™\n\n"
                f"ğŸ¯ TwÃ³j cel: {target_multi}x\n"
                f"ğŸ“ˆ Rakieta dotarÅ‚a do: {crash_point}x\n"
                f"ğŸ’° Wygrana: {win} DMT\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )
        else:
            # Przegrana
            final_points = get_user_points(user_id)
            await update.message.reply_text(
                f"ğŸ’¥ **RAKIETA SPADÅA!** ğŸ’€\n\n"
                f"ğŸ¯ TwÃ³j cel: {target_multi}x\n"
                f"ğŸ“‰ Rakieta spadÅ‚a na: {crash_point}x\n"
                f"ğŸ’¸ Stracone: {bet} DMT\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w crash_game: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w crash game!")

async def wheel_of_fortune(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        if not context.args:
            await update.message.reply_text(
                "ğŸ¡ **KOÅO FORTUNY DON MLEKO**\n\n"
                "ZakrÄ™Ä‡ koÅ‚em i zobacz co wypadnie!\n"
                "UÅ¼ycie: `/wheel [stawka]`\n\n"
                "ğŸ¯ Stawka: 20-150 DMT\n\n"
                "ğŸ **NAGRODY:**\n"
                "ğŸ’ JACKPOT (1%) - x20\n"
                "ğŸš€ DMT TO MOON (5%) - x10\n"
                "ğŸ’° DuÅ¼a wygrana (10%) - x5\n"
                "ğŸ¥› Don Mleko (15%) - x3\n"
                "ğŸ„ Krowa (25%) - x2\n"
                "ğŸ˜¢ Nic (44%) - x0\n\n"
                "ğŸ„ **Don Mleko zawsze nagradza!**"
            )
            return

        try:
            bet = int(context.args[0])
        except ValueError:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ liczbÄ…!")
            return

        if bet < 20 or bet > 150:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ miÄ™dzy 20 a 150 DMT!")
            return

        points = get_user_points(user_id)
        if points < bet:
            await update.message.reply_text("âŒ Nie masz wystarczajÄ…co DMT!")
            return

        add_points(user_id, -bet)

        # KoÅ‚o fortuny
        wheel_options = [
            {"name": "ğŸ’ JACKPOT", "chance": 1, "multiplier": 20, "emoji": "ğŸ’"},
            {"name": "ğŸš€ DMT TO MOON", "chance": 5, "multiplier": 10, "emoji": "ğŸš€"},
            {"name": "ğŸ’° DuÅ¼a wygrana", "chance": 10, "multiplier": 5, "emoji": "ğŸ’°"},
            {"name": "ğŸ¥› Don Mleko", "chance": 15, "multiplier": 3, "emoji": "ğŸ¥›"},
            {"name": "ğŸ„ Krowa", "chance": 25, "multiplier": 2, "emoji": "ğŸ„"},
            {"name": "ğŸ˜¢ Nic", "chance": 44, "multiplier": 0, "emoji": "ğŸ˜¢"}
        ]

        rand = random.randint(1, 100)
        cumulative = 0

        for option in wheel_options:
            cumulative += option["chance"]
            if rand <= cumulative:
                result = option
                break

        if result["multiplier"] > 0:
            win = bet * result["multiplier"]
            final_points = add_points(user_id, win)

            await update.message.reply_text(
                f"ğŸ¡ **KOÅO FORTUNY** ğŸ‰\n\n"
                f"ğŸ¯ WypadÅ‚o: {result['name']}\n"
                f"ğŸŠ Animacja: {result['emoji']}{result['emoji']}{result['emoji']}\n"
                f"ğŸ’° Wygrana: {win} DMT (x{result['multiplier']})\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )
        else:
            final_points = get_user_points(user_id)
            await update.message.reply_text(
                f"ğŸ¡ **KOÅO FORTUNY** ğŸ’€\n\n"
                f"ğŸ¯ WypadÅ‚o: {result['name']}\n"
                f"ğŸ˜¢ Nic nie wygraÅ‚eÅ› tym razem!\n"
                f"ğŸ’¸ Stracone: {bet} DMT\n"
                f"ğŸ’ Masz teraz: {final_points} DMT"
            )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w wheel_of_fortune: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w kole fortuny!")

# === SYSTEM WERBOWANIA ===

def can_recruit(user_id):
    """Sprawdza czy uÅ¼ytkownik moÅ¼e werbowaÄ‡"""
    user_data = get_user_data_full(user_id)
    respect = user_data.get('mafia_respect', 0)
    rank = get_mafia_rank(respect)
    return rank in ['Capo', 'Underboss', 'Don'] or respect >= 300

def get_recruitment_bonus(recruiter_rank):
    """Bonus za werbowanie w zaleÅ¼noÅ›ci od rangi"""
    bonuses = {
        'Capo': 50,
        'Underboss': 100,
        'Don': 200
    }
    return bonuses.get(recruiter_rank, 25)

def add_to_chat_channel(user_id, channel):
    """Dodaje uÅ¼ytkownika do kanaÅ‚u czatu"""
    user_data = get_user_data_full(user_id)
    channels = user_data.get('chat_channels', ['rodzina'])
    if channel not in channels:
        channels.append(channel)
        update_user_data(user_id, {'chat_channels': channels})
        return True
    return False

def can_access_channel(user_id, channel):
    """Sprawdza czy uÅ¼ytkownik ma dostÄ™p do kanaÅ‚u"""
    if channel not in CHAT_CHANNELS:
        return False

    user_data = get_user_data_full(user_id)
    user_respect = user_data.get('mafia_respect', 0)
    required_respect = CHAT_CHANNELS[channel]['min_respect']

    return user_respect >= required_respect

async def recruit_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        if not can_recruit(user_id):
            await update.message.reply_text("âŒ Musisz byÄ‡ przynajmniej Capo aby werbowaÄ‡ nowych czÅ‚onkÃ³w!")
            return

        if not context.args:
            recruited = user_data.get('recruited_members', [])
            recruiter_rank = get_mafia_rank(user_data.get('mafia_respect', 0))
            bonus = get_recruitment_bonus(recruiter_rank)

            await update.message.reply_text(
                f"ğŸ‘¥ **SYSTEM WERBOWANIA MAFII**\n\n"
                f"ğŸ‘¤ Twoja ranga: {recruiter_rank}\n"
                f"ğŸ’° Bonus za werbowanie: {bonus} DMT\n"
                f"ğŸ¯ Zwerbowani przez Ciebie: {len(recruited)}\n\n"
                f"**INSTRUKCJA:**\n"
                f"1. Nowy gracz musi uÅ¼yÄ‡: `/recruit [twÃ³j_username]`\n"
                f"2. Otrzymasz bonus za kaÅ¼dego nowego czÅ‚onka\n"
                f"3. Twoi podopieczni dostajÄ… specjalne misje\n\n"
                f"**TWÃ“J KOD WERBUNKOWY:**\n"
                f"`{update.effective_user.username or user_id}`\n\n"
                f"ğŸ‘‘ **HIERARCHIA WERBOWANIA:**\n"
                f"ğŸ„ Don Mleko â†’ ğŸ¦Œ BiaÅ‚y Rogacz â†’ Donowie â†’ Underboss â†’ Capo",
                parse_mode='Markdown'
            )
            return

        # Kod werbunkowy zostaÅ‚ podany - prÃ³ba werbowania
        recruiter_code = context.args[0]
        data = load_user_data()

        # ZnajdÅº rekrutera
        recruiter_id = None
        for uid, udata in data.items():
            username = None
            try:
                chat_member = await update.get_bot().get_chat(uid)
                username = chat_member.username
            except:
                pass

            if username == recruiter_code or uid == recruiter_code:
                recruiter_id = uid
                break

        if not recruiter_id or not can_recruit(int(recruiter_id)):
            await update.message.reply_text("âŒ NieprawidÅ‚owy kod werbunkowy lub rekruter nie ma uprawnieÅ„!")
            return

        if user_data.get('recruited_by'):
            await update.message.reply_text("âŒ JuÅ¼ zostaÅ‚eÅ› zwerbowany przez kogoÅ› innego!")
            return

        # Werbowanie!
        recruiter_data = get_user_data_full(int(recruiter_id))
        recruiter_rank = get_mafia_rank(recruiter_data.get('mafia_respect', 0))
        bonus = get_recruitment_bonus(recruiter_rank)

        # Aktualizuj dane rekrutera
        recruited_list = recruiter_data.get('recruited_members', [])
        recruited_list.append(str(user_id))
        update_user_data(int(recruiter_id), {
            'recruited_members': recruited_list,
            'last_recruitment': time.time()
        })
        add_points(int(recruiter_id), bonus)

        # Aktualizuj dane nowego czÅ‚onka
        starting_bonus = 25 + (bonus // 2)
        update_user_data(user_id, {
            'recruited_by': recruiter_id,
            'mafia_respect': 25,
            'chat_channels': ['rodzina']
        })
        add_points(user_id, starting_bonus)

        await update.message.reply_text(
            f"ğŸ‰ **ZOSTAÅEÅš ZWERBOWANY!**\n\n"
            f"ğŸ‘¤ Zwerbowany przez: {recruiter_rank}\n"
            f"ğŸ’° Bonus startowy: +{starting_bonus} DMT\n"
            f"â­ Szacunek startowy: +25\n"
            f"ğŸ“± DostÄ™p do kanaÅ‚u rodziny\n\n"
            f"ğŸ¤µ Witaj w rodzinie Don Mleko!"
        )

        # Powiadom rekrutera
        try:
            await update.get_bot().send_message(
                chat_id=int(recruiter_id),
                text=f"ğŸ‰ **NOWY REKRUT!**\n\n"
                     f"ğŸ‘¤ ZwerbowaÅ‚eÅ› nowego czÅ‚onka!\n"
                     f"ğŸ’° Bonus: +{bonus} DMT\n"
                     f"ğŸ¯ ÅÄ…cznie zwerbowanych: {len(recruited_list)}"
            )
        except:
            pass

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w recruit_member: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie werbowania!")

async def chat_system(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        if not context.args:
            # PokaÅ¼ dostÄ™pne kanaÅ‚y
            channels_text = "ğŸ’¬ **KANAÅY RODZINY DON MLEKO:**\n\n"
            user_channels = user_data.get('chat_channels', ['rodzina'])

            for channel, info in CHAT_CHANNELS.items():
                if can_access_channel(user_id, channel):
                    status = "âœ…" if channel in user_channels else "ğŸ”“"
                    channels_text += f"{status} {info['name']}\n"
                    channels_text += f"   ğŸ“ {info['description']}\n\n"
                else:
                    channels_text += f"ğŸ”’ {info['name']} (wymagane: {info['min_respect']} szacunek)\n\n"

            channels_text += (
                f"**INSTRUKCJA:**\n"
                f"ğŸ“ `/chat [kanaÅ‚] [wiadomoÅ›Ä‡]` - wyÅ›lij wiadomoÅ›Ä‡\n"
                f"ğŸ‘€ `/chat [kanaÅ‚]` - zobacz ostatnie wiadomoÅ›ci\n\n"
                f"**DOSTÄ˜PNE KANAÅY:**\n"
                f"rodzina, capo, underboss, don, tajny"
            )

            await update.message.reply_text(channels_text, parse_mode='Markdown')
            return

        channel = context.args[0].lower()

        if channel not in CHAT_CHANNELS:
            await update.message.reply_text("âŒ Nieznany kanaÅ‚! DostÄ™pne: rodzina, capo, underboss, don, tajny")
            return

        if not can_access_channel(user_id, channel):
            required = CHAT_CHANNELS[channel]['min_respect']
            await update.message.reply_text(f"âŒ Brak dostÄ™pu! Wymagane: {required} szacunek")
            return

        if len(context.args) == 1:
            # PokaÅ¼ ostatnie wiadomoÅ›ci
            messages = load_chat_messages(channel)
            if not messages:
                await update.message.reply_text(f"ğŸ’¬ KanaÅ‚ {CHAT_CHANNELS[channel]['name']} jest pusty")
                return

            messages_text = f"ğŸ’¬ **{CHAT_CHANNELS[channel]['name']}** (ostatnie 10):\n\n"
            for msg in messages[-10:]:
                time_str = datetime.fromtimestamp(msg['timestamp']).strftime("%H:%M")
                messages_text += f"[{time_str}] **{msg['username']}**: {msg['message']}\n"

            await update.message.reply_text(messages_text, parse_mode='Markdown')
            return

        # WyÅ›lij wiadomoÅ›Ä‡
        message = ' '.join(context.args[1:])
        if len(message) > 200:
            await update.message.reply_text("âŒ WiadomoÅ›Ä‡ za dÅ‚uga! Maksymalnie 200 znakÃ³w.")
            return

        username = update.effective_user.first_name or f"CzÅ‚onek#{str(user_id)[-4:]}"
        save_chat_message(channel, user_id, username, message)

        # Aktualizuj statystyki uÅ¼ytkownika
        user_data['message_count'] = user_data.get('message_count', 0) + 1
        user_data['last_message'] = time.time()
        update_user_data(user_id, user_data)

        await update.message.reply_text(
            f"âœ… WiadomoÅ›Ä‡ wysÅ‚ana na kanaÅ‚ {CHAT_CHANNELS[channel]['name']}!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w chat_system: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie czatu!")

def load_chat_messages(channel):
    """Åaduje wiadomoÅ›ci z kanaÅ‚u"""
    try:
        filename = f"chat_{channel}.json"
        if os.path.exists(filename):
            with open(filename, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return []

def save_chat_message(channel, user_id, username, message):
    """Zapisuje wiadomoÅ›Ä‡ do kanaÅ‚u"""
    try:
        messages = load_chat_messages(channel)

        new_message = {
            'user_id': str(user_id),
            'username': username,
            'message': message,
            'timestamp': time.time()
        }

        messages.append(new_message)

        # Zachowaj tylko ostatnie 100 wiadomoÅ›ci
        if len(messages) > 100:
            messages = messages[-100:]

        filename = f"chat_{channel}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(messages, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d zapisywania wiadomoÅ›ci: {e}")

# === FUNKCJE GILDII ===

def load_guilds_data():
    """Åaduje dane gildii"""
    try:
        if os.path.exists(GUILDS_FILE):
            with open(GUILDS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return {}

def save_guilds_data(guilds_data):
    """Zapisuje dane gildii"""
    try:
        with open(GUILDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(guilds_data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d zapisywania gildii: {e}")

def get_user_guild(user_id):
    """Pobiera gildiÄ™ uÅ¼ytkownika"""
    guilds_data = load_guilds_data()
    for guild_id, guild in guilds_data.items():
        if str(user_id) in guild.get('members', []):
            return guild_id, guild
    return None, None

def get_guild_level(member_count):
    """Oblicza poziom gildii na podstawie liczby czÅ‚onkÃ³w"""
    for level in sorted(GUILD_LEVELS.keys(), reverse=True):
        if member_count >= GUILD_LEVELS[level]['members_required']:
            return level
    return 1

async def guild_system(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """System gildii - gÅ‚Ã³wne menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)
        guild_id, guild = get_user_guild(user_id)

        if not context.args:
            if guild:
                # UÅ¼ytkownik ma gildiÄ™ - pokaÅ¼ menu gildii
                member_count = len(guild.get('members', []))
                guild_level = get_guild_level(member_count)
                guild_exp = guild.get('experience', 0)
                last_mission = guild.get('last_mission', 0)
                now = time.time()

                guild_text = (
                    f"ğŸ›ï¸ **TWOJA GILDIA: {guild['name']}**\n\n"
                    f"ğŸ‘‘ Lider: {guild['leader_name']}\n"
                    f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n"
                    f"ğŸ“Š Poziom: {guild_level} - {GUILD_LEVELS[guild_level]['name']}\n"
                    f"â­ DoÅ›wiadczenie: {guild_exp}\n"
                    f"ğŸ’° Bonus gildii: +{GUILD_LEVELS[guild_level]['bonus']}%\n\n"
                )

                # SprawdÅº cooldown misji gildijnych
                if now - last_mission < 3600:  # 1 godzina miÄ™dzy misjami
                    remaining = int(3600 - (now - last_mission))
                    guild_text += f"â° NastÄ™pna misja za {remaining//60}m {remaining%60}s\n\n"
                else:
                    guild_text += "âœ… Misje gildijne dostÄ™pne!\n\n"

                guild_text += (
                    "**KOMENDY GILDII:**\n"
                    "ğŸ‘¥ `/guild members` - Lista czÅ‚onkÃ³w\n"
                    "ğŸ¯ `/guild mission` - Misje grupowe\n"
                    "ğŸ“Š `/guild stats` - Statystyki gildii\n"
                    "ğŸ’¬ `/guild chat [wiadomoÅ›Ä‡]` - Czat gildii\n"
                    "ğŸ‘‘ `/guild invite [user_id]` - ZaproÅ› (lider)\n"
                    "ğŸšª `/guild leave` - OpuÅ›Ä‡ gildiÄ™\n"
                    "ğŸ’¸ `/guild donate [kwota]` - WpÅ‚aÄ‡ do skarbca"
                )

                await update.message.reply_text(guild_text, parse_mode='Markdown')
            else:
                # UÅ¼ytkownik nie ma gildii - pokaÅ¼ opcje
                guilds_data = load_guilds_data()
                open_guilds = [(gid, g) for gid, g in guilds_data.items() if g.get('recruitment_open', True) and len(g.get('members', [])) < 30]

                guild_text = (
                    "ğŸ›ï¸ **SYSTEM GILDII DON MLEKO**\n\n"
                    "ğŸ¯ **NIE MASZ GILDII!**\n\n"
                    "**OPCJE:**\n"
                    "ğŸ†• `/guild create [nazwa]` - UtwÃ³rz nowÄ… gildiÄ™ (1000 DMT)\n"
                    "ğŸ” `/guild list` - Zobacz dostÄ™pne gildie\n"
                    "ğŸ¤ `/guild join [id_gildii]` - DoÅ‚Ä…cz do gildii\n\n"
                    "ğŸ† **KORZYÅšCI Z GILDII:**\n"
                    "â€¢ Bonusy do wszystkich nagrÃ³d\n"
                    "â€¢ WspÃ³lne misje z mega nagrodami\n"
                    "â€¢ Prywatny czat gildii\n"
                    "â€¢ Wzajemna pomoc miÄ™dzy czÅ‚onkami\n"
                    "â€¢ Rywalizacja z innymi gildiami\n\n"
                    f"ğŸŒŸ **DostÄ™pne gildie: {len(open_guilds)}**\n"
                    "ğŸ’¡ Gildie mogÄ… mieÄ‡ maksymalnie 30 czÅ‚onkÃ³w!"
                )

                await update.message.reply_text(guild_text, parse_mode='Markdown')
            return

        action = context.args[0].lower()

        if action == "create":
            # Tworzenie nowej gildii
            if guild:
                await update.message.reply_text("âŒ JuÅ¼ naleÅ¼ysz do gildii! OpuÅ›Ä‡ jÄ… najpierw za pomocÄ… `/guild leave`")
                return

            if len(context.args) < 2:
                await update.message.reply_text("âŒ UÅ¼ycie: `/guild create [nazwa gildii]`")
                return

            guild_name = ' '.join(context.args[1:])
            if len(guild_name) > 50:
                await update.message.reply_text("âŒ Nazwa gildii za dÅ‚uga! Maksymalnie 50 znakÃ³w.")
                return

            # SprawdÅº koszt
            cost = 1000
            if user_data.get('points', 0) < cost:
                await update.message.reply_text(f"âŒ Potrzebujesz {cost} DMT aby utworzyÄ‡ gildiÄ™!")
                return

            # SprawdÅº czy nazwa nie jest zajÄ™ta
            guilds_data = load_guilds_data()
            for existing_guild in guilds_data.values():
                if existing_guild.get('name', '').lower() == guild_name.lower():
                    await update.message.reply_text("âŒ Ta nazwa gildii jest juÅ¼ zajÄ™ta!")
                    return

            # UtwÃ³rz gildiÄ™
            add_points(user_id, -cost)
            guild_id = f"guild_{int(time.time())}_{user_id}"
            username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"

            new_guild = {
                'name': guild_name,
                'leader_id': str(user_id),
                'leader_name': username,
                'members': [str(user_id)],
                'created_at': time.time(),
                'experience': 0,
                'treasury': 0,
                'missions_completed': 0,
                'last_mission': 0,
                'recruitment_open': True,
                'description': 'Nowa gildia w rodzinie Don Mleko!'
            }

            guilds_data[guild_id] = new_guild
            save_guilds_data(guilds_data)

            # Dodaj odznakÄ™ zaÅ‚oÅ¼yciela gildii
            check_and_award_badge(user_id, "guild_founder")

            await update.message.reply_text(
                f"ğŸ›ï¸ **GILDIA UTWORZONA!**\n\n"
                f"ğŸ‘‘ Nazwa: **{guild_name}**\n"
                f"ğŸ‘¤ Lider: {username}\n"
                f"ğŸ’¸ Koszt: {cost} DMT\n"
                f"ğŸ’ PozostaÅ‚o: {get_user_points(user_id)} DMT\n\n"
                f"ğŸ¯ **NastÄ™pne kroki:**\n"
                f"ğŸ‘¥ ZaproÅ› czÅ‚onkÃ³w: `/guild invite [user_id]`\n"
                f"ğŸ¯ Wykonuj misje grupowe dla bonusÃ³w\n"
                f"ğŸ“ˆ Rozwijaj gildiÄ™ zbierajÄ…c doÅ›wiadczenie!\n\n"
                f"ğŸ… ZdobyÅ‚eÅ› odznakÄ™: ZaÅ‚oÅ¼yciel Gildii!"
            )

        elif action == "list":
            # Lista dostÄ™pnych gildii
            guilds_data = load_guilds_data()
            open_guilds = [(gid, g) for gid, g in guilds_data.items() if g.get('recruitment_open', True)]

            if not open_guilds:
                await update.message.reply_text("ğŸ›ï¸ **Brak dostÄ™pnych gildii!**\n\nğŸ’¡ UtwÃ³rz pierwszÄ…: `/guild create [nazwa]`")
                return

            guild_list = "ğŸ›ï¸ **DOSTÄ˜PNE GILDIE:**\n\n"

            for guild_id, guild_data in open_guilds:
                member_count = len(guild_data.get('members', []))
                guild_level = get_guild_level(member_count)
                guild_list += (
                    f"ğŸ†” **ID:** `{guild_id[-8:]}`\n"
                    f"ğŸ‘‘ **{guild_data['name']}**\n"
                    f"ğŸ‘¤ Lider: {guild_data['leader_name']}\n"
                    f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n"
                    f"ğŸ“Š Poziom: {guild_level} - {GUILD_LEVELS[guild_level]['name']}\n"
                    f"ğŸ’° Bonus: +{GUILD_LEVELS[guild_level]['bonus']}%\n"
                    f"ğŸ“ {guild_data.get('description', 'Brak opisu')}\n\n"
                    f"ğŸ¤ DoÅ‚Ä…cz: `/guild join {guild_id[-8:]}`\n\n"
                )

            await update.message.reply_text(guild_list, parse_mode='Markdown')

        elif action == "join":
            # DoÅ‚Ä…czanie do gildii
            if guild:
                await update.message.reply_text("âŒ JuÅ¼ naleÅ¼ysz do gildii!")
                return

            if len(context.args) < 2:
                await update.message.reply_text("âŒ UÅ¼ycie: `/guild join [id_gildii]`\nSprawdÅº ID w `/guild list`")
                return

            target_guild_short_id = context.args[1]
            guilds_data = load_guilds_data()

            # ZnajdÅº gildiÄ™ po skrÃ³conym ID
            target_guild_id = None
            for gid in guilds_data.keys():
                if gid.endswith(target_guild_short_id):
                    target_guild_id = gid
                    break

            if not target_guild_id:
                await update.message.reply_text("âŒ Nie znaleziono gildii o tym ID!")
                return

            target_guild = guilds_data[target_guild_id]

            if len(target_guild.get('members', [])) >= 30:
                await update.message.reply_text("âŒ Ta gildia jest peÅ‚na!")
                return

            if not target_guild.get('recruitment_open', True):
                await update.message.reply_text("âŒ Ta gildia nie rekrutuje nowych czÅ‚onkÃ³w!")
                return

            # DoÅ‚Ä…cz do gildii
            username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"
            target_guild['members'].append(str(user_id))
            guilds_data[target_guild_id] = target_guild
            save_guilds_data(guilds_data)

            # Powiadom o doÅ‚Ä…czeniu
            member_count = len(target_guild['members'])
            guild_level = get_guild_level(member_count)

            await update.message.reply_text(
                f"ğŸ›ï¸ **DOÅÄ„CZONO DO GILDII!**\n\n"
                f"ğŸ‘‘ Gildia: **{target_guild['name']}**\n"
                f"ğŸ‘¤ Lider: {target_guild['leader_name']}\n"
                f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n"
                f"ğŸ“Š Poziom: {guild_level}\n"
                f"ğŸ’° Bonus gildii: +{GUILD_LEVELS[guild_level]['bonus']}%\n\n"
                f"ğŸ‰ Witaj w rodzinie!"
            )

            # Powiadom lidera
            try:
                await update.get_bot().send_message(
                    chat_id=int(target_guild['leader_id']),
                    text=f"ğŸ‰ **NOWY CZÅONEK GILDII!**\n\n"
                         f"ğŸ‘¤ {username} doÅ‚Ä…czyÅ‚ do {target_guild['name']}!\n"
                         f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30"
                )
            except:
                pass

        elif action == "members":
            # Lista czÅ‚onkÃ³w gildii
            if not guild:
                await update.message.reply_text("âŒ Nie naleÅ¼ysz do Å¼adnej gildii!")
                return

            members_text = f"ğŸ‘¥ **CZÅONKOWIE GILDII: {guild['name']}**\n\n"
            member_count = len(guild.get('members', []))

            # Pobierz dane wszystkich czÅ‚onkÃ³w
            data = load_user_data()
            members_info = []

            for member_id in guild.get('members', []):
                if member_id in data:
                    member_data = data[member_id]
                    try:
                        chat_member = await update.get_bot().get_chat(member_id)
                        username = chat_member.first_name or f"Gracz{member_id[-4:]}"
                    except:
                        username = f"Gracz{member_id[-4:]}"

                    members_info.append({
                        'id': member_id,
                        'name': username,
                        'points': member_data.get('points', 0),
                        'respect': member_data.get('mafia_respect', 0),
                        'is_leader': member_id == guild['leader_id']
                    })

            # Sortuj wedÅ‚ug punktÃ³w
            members_info.sort(key=lambda x: x['points'], reverse=True)

            for i, member in enumerate(members_info, 1):
                leader_icon = "ğŸ‘‘ " if member['is_leader'] else ""
                rank = get_mafia_rank(member['respect'])

                members_text += (
                    f"{i}. {leader_icon}**{member['name']}**\n"
                    f"   ğŸ’ {member['points']:,} DMT | â­ {member['respect']} | ğŸ¤µ {rank}\n\n"
                )

            guild_level = get_guild_level(member_count)
            members_text += (
                f"ğŸ“Š **PODSUMOWANIE:**\n"
                f"ğŸ‘¥ ÅÄ…cznie czÅ‚onkÃ³w: {member_count}/30\n"
                f"ğŸ“Š Poziom gildii: {guild_level}\n"
                f"ğŸ’° Bonus: +{GUILD_LEVELS[guild_level]['bonus']}%"
            )

            await update.message.reply_text(members_text, parse_mode='Markdown')

        elif action == "mission":
            # Misje gildijne
            if not guild:
                await update.message.reply_text("âŒ Nie naleÅ¼ysz do Å¼adnej gildii!")
                return

            member_count = len(guild.get('members', []))
            available_missions = [m for m in GUILD_MISSIONS if member_count >= m['min_members']]

            if not available_missions:
                await update.message.reply_text(
                    f"âŒ **BRAK DOSTÄ˜PNYCH MISJI!**\n\n"
                    f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n"
                    f"ğŸ¯ Najmniejsza misja wymaga 3 czÅ‚onkÃ³w\n\n"
                    f"ğŸ’¡ Zwerbujcie wiÄ™cej czÅ‚onkÃ³w!"
                )
                return

            # SprawdÅº cooldown
            last_mission = guild.get('last_mission', 0)
            now = time.time()

            if now - last_mission < 3600:  # 1 godzina
                remaining = int(3600 - (now - last_mission))
                await update.message.reply_text(f"â° NastÄ™pna misja gildii za {remaining//60}m {remaining%60}s!")
                return

            if len(context.args) < 2:
                missions_text = "ğŸ¯ **DOSTÄ˜PNE MISJE GILDII:**\n\n"
                missions_text += f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n\n"

                for i, mission in enumerate(available_missions, 1):
                    missions_text += (
                        f"{i}. **{mission['name']}** ({mission['difficulty']})\n"
                        f"   ğŸ“ {mission['description']}\n"
                        f"   ğŸ‘¥ Wymagane: {mission['min_members']} czÅ‚onkÃ³w\n"
                        f"   ğŸ’° Nagroda: {mission['reward_per_member'][0]}-{mission['reward_per_member'][1]} DMT/osoba\n"
                        f"   â­ DoÅ›wiadczenie: +{mission['guild_experience']}\n"
                        f"   â° Cooldown: {mission['cooldown']//3600}h\n\n"
                    )

                missions_text += "UÅ¼yj: `/guild mission [numer]` aby rozpoczÄ…Ä‡ misjÄ™"
                await update.message.reply_text(missions_text, parse_mode='Markdown')
                return

            # Rozpocznij misjÄ™
            try:
                mission_id = int(context.args[1]) - 1
                if mission_id < 0 or mission_id >= len(available_missions):
                    raise ValueError
            except ValueError:
                await update.message.reply_text("âŒ Podaj prawidÅ‚owy numer misji!")
                return

            mission = available_missions[mission_id]

            # SprawdÅº czy uÅ¼ytkownik to lider
            if str(user_id) != guild['leader_id']:
                await update.message.reply_text("âŒ Tylko lider gildii moÅ¼e rozpoczynaÄ‡ misje!")
                return

            # Rozpocznij misjÄ™ gildijnÄ…
            success_chance = min(90, 50 + get_guild_level(member_count) * 10)

            if random.randint(1, 100) <= success_chance:
                # Sukces!
                guilds_data = load_guilds_data()
                guild = guilds_data[guild_id]

                # Nagrody dla wszystkich czÅ‚onkÃ³w
                rewards_given = 0
                for member_id in guild['members']:
                    reward = random.randint(*mission['reward_per_member'])
                    add_points(int(member_id), reward)
                    rewards_given += reward

                # Aktualizuj gildiÄ™
                guild['last_mission'] = now
                guild['experience'] += mission['guild_experience']
                guild['missions_completed'] = guild.get('missions_completed', 0) + 1
                guilds_data[guild_id] = guild
                save_guilds_data(guilds_data)

                # Powiadom wszystkich czÅ‚onkÃ³w
                for member_id in guild['members']:
                    try:
                        await update.get_bot().send_message(
                            chat_id=int(member_id),
                            text=f"ğŸ‰ **MISJA GILDII UDANA!**\n\n"
                                 f"ğŸ¯ {mission['name']}\n"
                                 f"ğŸ’° Twoja nagroda: {random.randint(*mission['reward_per_member'])} DMT\n"
                                 f"â­ DoÅ›wiadczenie gildii: +{mission['guild_experience']}\n\n"
                                 f"ğŸ›ï¸ Gildia: {guild['name']}"
                        )
                    except:
                        pass

                await update.message.reply_text(
                    f"ğŸ‰ **MISJA GILDII UDANA!**\n\n"
                    f"ğŸ¯ {mission['name']}\n"
                    f"ğŸ’° ÅÄ…czne nagrody: {rewards_given} DMT\n"
                    f"â­ DoÅ›wiadczenie: +{mission['guild_experience']}\n"
                    f"ğŸ‘¥ CzÅ‚onkowie nagrodzeni: {len(guild['members'])}\n\n"
                    f"ğŸ›ï¸ {guild['name']} staje siÄ™ silniejsza!"
                )
            else:
                # PoraÅ¼ka
                guilds_data = load_guilds_data()
                guild = guilds_data[guild_id]
                guild['last_mission'] = now
                guilds_data[guild_id] = guild
                save_guilds_data(guilds_data)

                await update.message.reply_text(
                    f"ğŸ’€ **MISJA NIEUDANA!**\n\n"
                    f"ğŸ¯ {mission['name']}\n"
                    f"ğŸ˜µ Gildia poniosÅ‚a poraÅ¼kÄ™!\n"
                    f"âš ï¸ Szanse byÅ‚y: {success_chance}%\n\n"
                    f"â° SprÃ³bujcie ponownie za godzinÄ™!"
                )

        elif action == "leave":
            # Opuszczenie gildii
            if not guild:
                await update.message.reply_text("âŒ Nie naleÅ¼ysz do Å¼adnej gildii!")
                return

            guilds_data = load_guilds_data()

            if str(user_id) == guild['leader_id']:
                if len(guild['members']) > 1:
                    await update.message.reply_text("âŒ Nie moÅ¼esz opuÅ›ciÄ‡ gildii jako lider! Najpierw przekaÅ¼ przywÃ³dztwo lub rozwiÄ…Å¼ gildiÄ™.")
                    return
                else:
                    # UsuÅ„ gildiÄ™ jeÅ›li lider byÅ‚ jedynym czÅ‚onkiem
                    del guilds_data[guild_id]
                    save_guilds_data(guilds_data)
                    await update.message.reply_text(f"ğŸ›ï¸ Gildia **{guild['name']}** zostaÅ‚a rozwiÄ…zana!")
                    return

            # UsuÅ„ czÅ‚onka z gildii
            guild['members'].remove(str(user_id))
            guilds_data[guild_id] = guild
            save_guilds_data(guilds_data)

            await update.message.reply_text(f"ğŸšª OpuÅ›ciÅ‚eÅ› gildiÄ™ **{guild['name']}**!")

        elif action == "stats":
            # Statystyki gildii
            if not guild:
                await update.message.reply_text("âŒ Nie naleÅ¼ysz do Å¼adnej gildii!")
                return

            member_count = len(guild.get('members', []))
            guild_level = get_guild_level(member_count)
            experience = guild.get('experience', 0)
            missions_completed = guild.get('missions_completed', 0)
            treasury = guild.get('treasury', 0)

            # Oblicz Å‚Ä…czne statystyki czÅ‚onkÃ³w
            data = load_user_data()
            total_points = 0
            total_respect = 0
            total_battles = 0

            for member_id in guild['members']:
                if member_id in data:
                    member_data = data[member_id]
                    total_points += member_data.get('points', 0)
                    total_respect += member_data.get('mafia_respect', 0)
                    total_battles += member_data.get('battle_wins', 0)

            stats_text = (
                f"ğŸ“Š **STATYSTYKI GILDII: {guild['name']}**\n\n"
                f"ğŸ‘‘ Lider: {guild['leader_name']}\n"
                f"ğŸ‘¥ CzÅ‚onkowie: {member_count}/30\n"
                f"ğŸ“Š Poziom gildii: {guild_level} - {GUILD_LEVELS[guild_level]['name']}\n"
                f"â­ DoÅ›wiadczenie: {experience}\n"
                f"ğŸ¯ UkoÅ„czone misje: {missions_completed}\n"
                f"ğŸ’° Skarbiec gildii: {treasury} DMT\n\n"
                f"ğŸ”¥ **SIÅA GILDII:**\n"
                f"ğŸ’ ÅÄ…czne punkty: {total_points:,}\n"
                f"â­ ÅÄ…czny szacunek: {total_respect:,}\n"
                f"âš”ï¸ ÅÄ…czne bitwy: {total_battles}\n\n"
                f"ğŸ† Bonus dla czÅ‚onkÃ³w: +{GUILD_LEVELS[guild_level]['bonus']}%"
            )

            await update.message.reply_text(stats_text, parse_mode='Markdown')

        else:
            await update.message.reply_text(
                "âŒ Nieznana akcja!\n\n"
                "**DOSTÄ˜PNE AKCJE:**\n"
                "â€¢ create [nazwa] - UtwÃ³rz gildiÄ™\n"
                "â€¢ list - Lista gildii\n"
                "â€¢ join [id] - DoÅ‚Ä…cz do gildii\n"
                "â€¢ members - CzÅ‚onkowie\n"
                "â€¢ mission [nr] - Misje grupowe\n"
                "â€¢ stats - Statystyki\n"
                "â€¢ leave - OpuÅ›Ä‡ gildiÄ™"
            )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w guild_system: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie gildii!")

# === FUNKCJE SYSTEMU SPOÅECZNOÅšCIOWEGO ===

def load_social_feed():
    """Åaduje posty z social feed"""
    try:
        if os.path.exists(FEED_POSTS_FILE):
            with open(FEED_POSTS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return []

def save_social_feed(posts):
    """Zapisuje posty do social feed"""
    try:
        with open(FEED_POSTS_FILE, 'w', encoding='utf-8') as f:
            json.dump(posts, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d zapisywania social feed: {e}")

def load_post_comments():
    """Åaduje komentarze do postÃ³w"""
    try:
        if os.path.exists(COMMENTS_FILE):
            with open(COMMENTS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return {}

def save_post_comments(comments):
    """Zapisuje komentarze do postÃ³w"""
    try:
        with open(COMMENTS_FILE, 'w', encoding='utf-8') as f:
            json.dump(comments, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d zapisywania komentarzy: {e}")

def load_post_likes():
    """Åaduje polubienia postÃ³w"""
    try:
        if os.path.exists(LIKES_FILE):
            with open(LIKES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return {}

def save_post_likes(likes):
    """Zapisuje polubienia postÃ³w"""
    try:
        with open(LIKES_FILE, 'w', encoding='utf-8') as f:
            json.dump(likes, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d zapisywania polubieÅ„: {e}")

def create_social_post(user_id, username, post_type, title, content, image_url=None):
    """Tworzy nowy post spoÅ‚ecznoÅ›ciowy"""
    try:
        posts = load_social_feed()

        post_id = f"post_{int(time.time())}_{user_id}"

        new_post = {
            'id': post_id,
            'user_id': str(user_id),
            'username': username,
            'type': post_type,
            'title': title,
            'content': content,
            'image_url': image_url,
            'timestamp': time.time(),
            'likes_count': 0,
            'comments_count': 0
        }

        posts.insert(0, new_post)  # Dodaj na poczÄ…tku

        # Zachowaj tylko ostatnie 500 postÃ³w
        if len(posts) > 500:
            posts = posts[:500]

        save_social_feed(posts)
        return post_id
    except Exception as e:
        logging.error(f"BÅ‚Ä…d tworzenia postu: {e}")
        return None

def auto_create_achievement_post(user_id, username, achievement_type, details):
    """Automatycznie tworzy post o osiÄ…gniÄ™ciu"""
    try:
        achievement_messages = {
            'level_up': f"ğŸ‰ AwansowaÅ‚ na nowy poziom mining! {details}",
            'mafia_rank': f"ğŸ¤µ AwansowaÅ‚ w mafii na rangÄ™ {details}!",
            'jackpot': f"ğŸ’° WygraÅ‚ MEGA JACKPOT! {details} DMT!",
            'badge': f"ğŸ… ZdobyÅ‚ nowÄ… odznakÄ™: {details}!",
            'territory': f"ğŸ° ZdobyÅ‚ nowe terytorium: {details}!",
            'boss_title': f"ğŸ‘‘ ZostaÅ‚ nowym bossem: {details}!",
            'heist_master': f"ğŸ’ ZostaÅ‚ mistrzem napadÃ³w! {details} udanych akcji!",
            'battle_champion': f"âš”ï¸ ZostaÅ‚ championem areny! {details} zwyciÄ™stw!"
        }

        if achievement_type in achievement_messages:
            title = f"{achievement_messages[achievement_type]}"
            content = f"ğŸ¯ Gratulacje dla {username}! Niesamowite osiÄ…gniÄ™cie w rodzinie Don Mleko!"

            return create_social_post(user_id, username, 'achievement', title, content)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d auto-postu: {e}")
        return None

async def show_missions_category(query, user_data, category, title):
    """Pokazuje misje z wybranej kategorii"""
    try:
        user_id = query.from_user.id
        respect = user_data.get('mafia_respect', 0)
        rank = get_mafia_rank(respect)

        # Filtruj misje wedÅ‚ug kategorii
        category_missions = []
        difficulty_mapping = {
            'easy': ['Å‚atwy'],
            'medium': ['Å›redni'],
            'hard': ['trudny', 'bardzo trudny'],
            'expert': ['ekspert', 'legendarna', 'mityczna', 'boski', 'transcendentny']
        }

        for i, mission in enumerate(MISSIONS, 1):
            if mission['difficulty'] in difficulty_mapping[category]:
                category_missions.append((i, mission))

        missions_text = f"{title}\n\n"
        missions_text += f"ğŸ‘¤ Twoja ranga: {rank}\n"
        missions_text += f"â­ Szacunek: {respect}\n\n"

        # SprawdÅº cooldown
        last_mission = user_data.get('last_mission', 0)
        now = time.time()
        cooldown_active = now - last_mission < 1800

        if cooldown_active:
            remaining = int(1800 - (now - last_mission))
            missions_text += f"â° NastÄ™pna misja za {remaining//60}m {remaining%60}s!\n\n"

        keyboard = []

        # Dodaj przyciski dla misji w kategorii
        for i, (mission_index, mission) in enumerate(category_missions, 1):
            success_bonus = MAFIA_RANKS[rank]['bonus']
            base_chance = {
                'Å‚atwy': 80, 'Å›redni': 60, 'trudny': 40, 'bardzo trudny': 20,
                'ekspert': 15, 'legendarna': 10, 'mityczna': 5, 'boski': 3, 'transcendentny': 1
            }
            success_chance = min(95, base_chance.get(mission['difficulty'], 50) + success_bonus)

            missions_text += (
                f"{i}. **{mission['name']}** ({mission['difficulty']})\n"
                f"   ğŸ“ {mission['description']}\n"
                f"   ğŸ’° Nagroda: {mission['reward'][0]}-{mission['reward'][1]} DMT\n"
                f"   â­ Szacunek: +{mission['respect']}\n"
                f"   â±ï¸ Czas: {mission['time_required']//60} min\n"
                f"   ğŸ¯ Szanse: ~{success_chance}%\n\n"
            )

            # Dodaj przycisk tylko jeÅ›li nie ma cooldown
            if not cooldown_active:
                button_text = f"ğŸ¯ {mission['name']}"
                if len(button_text) > 30:  # SkrÃ³Ä‡ dÅ‚ugie nazwy
                    button_text = button_text[:27] + "..."

                keyboard.append([InlineKeyboardButton(
                    button_text,
                    callback_data=f"start_mission_{mission_index}"
                )])

        # Przyciski nawigacyjne
        nav_keyboard = [
            [InlineKeyboardButton("ğŸ”„ Wszystkie Misje", callback_data="missions")],
            [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
        ]

        keyboard.extend(nav_keyboard)
        reply_markup = InlineKeyboardMarkup(keyboard)

        if not category_missions:
            missions_text += "âŒ Brak misji w tej kategorii!"

        await query.edit_message_text(
            missions_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w show_missions_category: {e}")
        await query.answer("âŒ BÅ‚Ä…d przy Å‚adowaniu misji!", show_alert=True)

async def show_bosses(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        bosses_text = "ğŸ‘‘ **HIERARCHIA MAFII DON MLEKO:**\n\n"

        for boss_id, boss_info in MAFIA_BOSSES.items():
            bosses_text += (
                f"{boss_info['name']}\n"
                f"ğŸ‘” {boss_info['title']}\n"
                f"â­ Szacunek: {boss_info['respect']:,}\n"
                f"ğŸ“ {boss_info['description']}\n"
                f"ğŸ”¥ {boss_info['special_power']}\n\n"
            )

        user_respect = user_data.get('mafia_respect', 0)
        user_rank = get_mafia_rank(user_respect)

        bosses_text += (
            f"**TWOJA POZYCJA:**\n"
            f"ğŸ‘¤ Ranga: {user_rank}\n"
            f"â­ Szacunek: {user_respect}\n\n"
            f"ğŸ’¡ Zdobywaj szacunek aby awansowaÄ‡ w hierarchii!"
        )

        # SprawdÅº czy gracz ma specjalne misje od bossÃ³w
        special_missions = user_data.get('special_missions', [])
        if special_missions:
            bosses_text += f"\nğŸ¯ Masz {len(special_missions)} specjalnych misji od bossÃ³w!"

        await update.message.reply_text(bosses_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w show_bosses: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w hierarchii bossÃ³w!")

# === KOMENDY SYSTEMU SPOÅECZNOÅšCIOWEGO ===

async def social_feed(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Pokazuje najnowsze posty spoÅ‚ecznoÅ›ciowe"""
    try:
        posts = load_social_feed()

        if not posts:
            await update.message.reply_text(
                "ğŸ“± **SOCIAL FEED RODZINY**\n\n"
                "ğŸ” Brak postÃ³w! BÄ…dÅº pierwszy!\n\n"
                "ğŸ’¡ UÅ¼ywaj:\n"
                "ğŸ“ `/post [typ] [tytuÅ‚] [treÅ›Ä‡]` - nowy post\n"
                "ğŸ‘ `/like [id]` - polub post\n"
                "ğŸ’¬ `/comment [id] [komentarz]` - skomentuj\n"
                "ğŸ“– `/read [id]` - czytaj post z komentarzami"
            )
            return

        # PokaÅ¼ ostatnie 10 postÃ³w
        feed_text = "ğŸ“± **NAJNOWSZE POSTY RODZINY:**\n\n"

        for post in posts[:10]:
            post_type = POST_TYPES.get(post['type'], 'ğŸ“ Post')
            time_ago = get_time_ago(post['timestamp'])

            feed_text += (
                f"ğŸ†” **ID: {post['id'][-8:]}** | {post_type}\n"
                f"ğŸ‘¤ **{post['username']}** â€¢ {time_ago}\n"
                f"ğŸ“ **{post['title']}**\n"
                f"ğŸ‘ {post['likes_count']} â€¢ ğŸ’¬ {post['comments_count']}\n\n"
            )

        feed_text += (
            "**KOMENDY:**\n"
            "ğŸ“ `/post [typ] [tytuÅ‚] [treÅ›Ä‡]` - napisz post\n"
            "ğŸ“– `/read [id]` - czytaj caÅ‚y post\n"
            "ğŸ‘ `/like [id]` - polub\n"
            "ğŸ’¬ `/comment [id] [treÅ›Ä‡]` - skomentuj\n\n"
            "**TYPY POSTÃ“W:** achievement, victory, jackpot, milestone, funny, help, announcement"
        )

        await update.message.reply_text(feed_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w social_feed: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w social feed!")

async def create_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Tworzy nowy post spoÅ‚ecznoÅ›ciowy"""
    try:
        user_id = update.effective_user.id
        username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"

        if not context.args or len(context.args) < 3:
            await update.message.reply_text(
                "ğŸ“ **TWORZENIE POSTU**\n\n"
                "UÅ¼ycie: `/post [typ] [tytuÅ‚] [treÅ›Ä‡]`\n\n"
                "ğŸ¯ **DOSTÄ˜PNE TYPY:**\n"
                "â€¢ achievement - ğŸ† OsiÄ…gniÄ™cie\n"
                "â€¢ victory - âš”ï¸ ZwyciÄ™stwo\n"
                "â€¢ jackpot - ğŸ’° Jackpot\n"
                "â€¢ milestone - ğŸ¯ KamieÅ„ milowy\n"
                "â€¢ funny - ğŸ˜‚ Zabawne\n"
                "â€¢ help - â“ Pomoc\n"
                "â€¢ announcement - ğŸ“¢ OgÅ‚oszenie\n\n"
                "ğŸ“ **PrzykÅ‚ad:**\n"
                "`/post victory 'Wygrana w blackjack' 'WÅ‚aÅ›nie wygraÅ‚em 500 DMT w blackjack! ğŸ‰'`"
            )
            return

        post_type = context.args[0].lower()
        if post_type not in POST_TYPES:
            await update.message.reply_text("âŒ NieprawidÅ‚owy typ postu! UÅ¼yj: achievement, victory, jackpot, milestone, funny, help, announcement")
            return

        # ZÅ‚Ä…cz resztÄ™ argumentÃ³w jako tytuÅ‚ i treÅ›Ä‡
        remaining_text = ' '.join(context.args[1:])

        # PrÃ³buj rozdzieliÄ‡ tytuÅ‚ i treÅ›Ä‡ (przez pierwszy pojedynczy cudzysÅ‚Ã³w lub pierwszy dwukropek)
        if "'" in remaining_text:
            parts = remaining_text.split("'")
            if len(parts) >= 3:
                title = parts[1]
                content = parts[2].strip()
            else:
                title = remaining_text[:50]
                content = remaining_text
        elif ":" in remaining_text:
            parts = remaining_text.split(":", 1)
            title = parts[0].strip()
            content = parts[1].strip()
        else:
            title = remaining_text[:50] + "..." if len(remaining_text) > 50 else remaining_text
            content = remaining_text

        if len(title) > 100:
            await update.message.reply_text("âŒ TytuÅ‚ za dÅ‚ugi! Maksymalnie 100 znakÃ³w.")
            return

        if len(content) > 500:
            await update.message.reply_text("âŒ TreÅ›Ä‡ za dÅ‚uga! Maksymalnie 500 znakÃ³w.")
            return

        # SprawdÅº cooldown (5 minut miÄ™dzy postami)
        user_data = get_user_data_full(user_id)
        last_post = user_data.get('last_post_time', 0)
        if time.time() - last_post < 300:
            remaining = int(300 - (time.time() - last_post))
            await update.message.reply_text(f"â° MoÅ¼esz napisaÄ‡ kolejny post za {remaining//60}m {remaining%60}s!")
            return

        # UtwÃ³rz post
        post_id = create_social_post(user_id, username, post_type, title, content)

        if post_id:
            # Aktualizuj dane uÅ¼ytkownika
            user_data['last_post_time'] = time.time()
            user_data['posts_created'] = user_data.get('posts_created', 0) + 1
            update_user_data(user_id, user_data)

            # Dodaj punkty za utworzenie postu
            points = add_points(user_id, 5)

            await update.message.reply_text(
                f"âœ… **POST UTWORZONY!**\n\n"
                f"ğŸ†” ID: {post_id[-8:]}\n"
                f"ğŸ¯ Typ: {POST_TYPES[post_type]}\n"
                f"ğŸ“ TytuÅ‚: {title}\n"
                f"ğŸ’ +5 punktÃ³w za post! Masz: {points}\n\n"
                f"ğŸ“± SprawdÅº `/feed` aby zobaczyÄ‡ swÃ³j post!"
            )
        else:
            await update.message.reply_text("âŒ BÅ‚Ä…d podczas tworzenia postu!")

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w create_post: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d podczas tworzenia postu!")

async def like_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Polub post"""
    try:
        user_id = update.effective_user.id

        if not context.args:
            await update.message.reply_text("ğŸ‘ UÅ¼ycie: `/like [ID postu]`\nSprawdÅº ID w `/feed`")
            return

        post_id_short = context.args[0]
        posts = load_social_feed()
        likes = load_post_likes()

        # ZnajdÅº post po skrÃ³conym ID
        target_post = None
        for post in posts:
            if post['id'].endswith(post_id_short):
                target_post = post
                break

        if not target_post:
            await update.message.reply_text("âŒ Nie znaleziono postu o tym ID!")
            return

        post_id = target_post['id']

        # SprawdÅº czy juÅ¼ polubiÅ‚
        if post_id not in likes:
            likes[post_id] = []

        if str(user_id) in likes[post_id]:
            # UsuÅ„ polubienie
            likes[post_id].remove(str(user_id))
            action = "usunÄ…Å‚eÅ› polubienie"
            emoji = "ğŸ’”"
        else:
            # Dodaj polubienie
            likes[post_id].append(str(user_id))
            action = "polubiÅ‚eÅ› post"
            emoji = "ğŸ‘"

            # Dodaj punkty autorowi postu (jeÅ›li to nie on sam)
            if target_post['user_id'] != str(user_id):
                add_points(int(target_post['user_id']), 1)

        # Aktualizuj licznik polubieÅ„ w poÅ›cie
        for i, post in enumerate(posts):
            if post['id'] == post_id:
                posts[i]['likes_count'] = len(likes[post_id])
                break

        save_post_likes(likes)
        save_social_feed(posts)

        await update.message.reply_text(
            f"{emoji} **{action.upper()}!**\n\n"
            f"ğŸ“ Post: {target_post['title'][:50]}{'...' if len(target_post['title']) > 50 else ''}\n"
            f"ğŸ‘¤ Autor: {target_post['username']}\n"
            f"ğŸ‘ ÅÄ…cznie polubieÅ„: {len(likes[post_id])}"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w like_post: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d podczas polubienia!")

async def comment_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Dodaj komentarz do postu"""
    try:
        user_id = update.effective_user.id
        username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"

        if not context.args or len(context.args) < 2:
            await update.message.reply_text(
                "ğŸ’¬ **SZYBKIE KOMENTOWANIE:**\n\n"
                "ğŸ“ `/comment [ID] [treÅ›Ä‡]` - peÅ‚ny komentarz\n"
                "âš¡ `/c [ID] [treÅ›Ä‡]` - szybki komentarz\n\n"
                "ğŸš€ **GOTOWE REAKCJE:**\n"
                "ğŸ‘ `/c [ID] +` - Åšwietne!\n"
                "ğŸ˜‚ `/c [ID] lol` - Haha!\n"
                "ğŸ”¥ `/c [ID] fire` - Super!\n"
                "ğŸ’ `/c [ID] dmt` - Do ksiÄ™Å¼yca!\n"
                "ğŸ„ `/c [ID] don` - Don Mleko approves!\n"
                "âš¡ `/c [ID] fast` - Szybko!\n"
                "â¤ï¸ `/c [ID] love` - Kocham to!\n"
                "ğŸ’ª `/c [ID] strong` - Mocne!"
            )
            return

        post_id_short = context.args[0]
        comment_text = ' '.join(context.args[1:])

        # Automatyczne rozszerzenie skrÃ³conych komentarzy
        quick_comments = {
            '+': 'ğŸ‘ Åšwietne!',
            'lol': 'ğŸ˜‚ Haha, dobre!',
            'fire': 'ğŸ”¥ Super sprawa!',
            'dmt': 'ğŸ’ DMT do ksiÄ™Å¼yca!',
            'don': 'ğŸ„ Don Mleko approves!',
            'fast': 'âš¡ Szybko i sprawnie!',
            'love': 'â¤ï¸ Kocham to!',
            'strong': 'ğŸ’ª Mocne!',
            'nice': 'ğŸ‘Œ Åadnie!',
            'wow': 'ğŸ˜® Wow!',
            'yes': 'âœ… Tak!',
            'no': 'âŒ Nie ma mowy!',
            'maybe': 'ğŸ¤” MoÅ¼e...',
            'king': 'ğŸ‘‘ KrÃ³l!',
            'legend': 'ğŸ† Legenda!',
            'moon': 'ğŸš€ Na ksiÄ™Å¼yc!',
            'mleko': 'ğŸ¥› Mleko power!',
            'mafia': 'ğŸ¤µ Rodzina!',
            'battle': 'âš”ï¸ Do bitwy!',
            'mining': 'â›ï¸ Kopalnia!'
        }

        if comment_text.lower() in quick_comments:
            comment_text = quick_comments[comment_text.lower()]

        if len(comment_text) > 200:
            await update.message.reply_text("âŒ Komentarz za dÅ‚ugi! Maksymalnie 200 znakÃ³w.")
            return

        posts = load_social_feed()
        comments = load_post_comments()

        # ZnajdÅº post
        target_post = None
        for post in posts:
            if post['id'].endswith(post_id_short):
                target_post = post
                break

        if not target_post:
            await update.message.reply_text("âŒ Nie znaleziono postu o tym ID!")
            return

        post_id = target_post['id']

        # Dodaj komentarz
        if post_id not in comments:
            comments[post_id] = []

        new_comment = {
            'user_id': str(user_id),
            'username': username,
            'comment': comment_text,
            'timestamp': time.time()
        }

        comments[post_id].append(new_comment)

        # Aktualizuj licznik komentarzy
        for i, post in enumerate(posts):
            if post['id'] == post_id:
                posts[i]['comments_count'] = len(comments[post_id])
                break

        save_post_comments(comments)
        save_social_feed(posts)

        # Dodaj punkty autorowi postu i komentujÄ…cemu
        if target_post['user_id'] != str(user_id):
            add_points(int(target_post['user_id']), 1)  # Autor dostaje punkt za komentarz
        points = add_points(user_id, 2)  # KomentujÄ…cy dostaje 2 punkty

        await update.message.reply_text(
            f"ğŸ’¬ **KOMENTARZ DODANY!**\n\n"
            f"ğŸ“ Do postu: {target_post['title'][:40]}{'...' if len(target_post['title']) > 40 else ''}\n"
            f"ğŸ‘¤ Autor postu: {target_post['username']}\n"
            f"ğŸ’¬ Komentarzy: {len(comments[post_id])}\n"
            f"ğŸ’ +2 punkty! Masz: {points}"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w comment_post: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d podczas dodawania komentarza!")

async def read_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Czytaj peÅ‚ny post z komentarzami"""
    try:
        if not context.args:
            await update.message.reply_text("ğŸ“– UÅ¼ycie: `/read [ID postu]`\nSprawdÅº ID w `/feed`")
            return

        post_id_short = context.args[0]
        posts = load_social_feed()
        comments = load_post_comments()
        likes = load_post_likes()

        # ZnajdÅº post
        target_post = None
        for post in posts:
            if post['id'].endswith(post_id_short):
                target_post = post
                break

        if not target_post:
            await update.message.reply_text("âŒ Nie znaleziono postu o tym ID!")
            return

        post_id = target_post['id']
        post_type = POST_TYPES.get(target_post['type'], 'ğŸ“ Post')
        time_ago = get_time_ago(target_post['timestamp'])

        # Zbuduj tekst postu
        post_text = (
            f"ğŸ“– **PEÅNY POST**\n\n"
            f"ğŸ†” ID: {post_id[-8:]}\n"
            f"ğŸ¯ Typ: {post_type}\n"
            f"ğŸ‘¤ Autor: **{target_post['username']}**\n"
            f"ğŸ•’ {time_ago}\n\n"
            f"ğŸ“ **{target_post['title']}**\n\n"
            f"{target_post['content']}\n\n"
            f"ğŸ‘ {len(likes.get(post_id, []))} polubieÅ„ â€¢ ğŸ’¬ {len(comments.get(post_id, []))} komentarzy"
        )

        # Dodaj komentarze (ostatnie 5)
        post_comments = comments.get(post_id, [])
        if post_comments:
            post_text += "\n\nğŸ’¬ **KOMENTARZE:**\n"
            recent_comments = post_comments[-5:]  # Ostatnie 5

            for comment in recent_comments:
                comment_time = get_time_ago(comment['timestamp'])
                post_text += f"\nğŸ‘¤ **{comment['username']}** â€¢ {comment_time}\nğŸ’­ {comment['comment']}\n"

            if len(post_comments) > 5:
                post_text += f"\n... i {len(post_comments) - 5} wiÄ™cej komentarzy"

        post_text += f"\n\n**AKCJE:**\nğŸ‘ `/like {post_id_short}` â€¢ ğŸ’¬ `/comment {post_id_short} [treÅ›Ä‡]`"

        await update.message.reply_text(post_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w read_post: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d podczas czytania postu!")

def get_time_ago(timestamp):
    """Zwraca czas jako 'X godzin temu' itp."""
    try:
        now = time.time()
        diff = int(now - timestamp)

        if diff < 60:
            return f"{diff}s temu"
        elif diff < 3600:
            return f"{diff//60}m temu"
        elif diff < 86400:
            return f"{diff//3600}h temu"
        else:
            return f"{diff//86400}d temu"
    except:
        return "niedawno"

async def mega_boost(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Aktywuj mega bonusy za DMT"""
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        if not context.args:
            active_boosts = user_data.get('active_boosts', {})
            boost_text = "ğŸš€ **MEGA BOOST SYSTEM**\n\n"

            boost_text += "**DOSTÄ˜PNE BOOSTY:**\n"
            boost_text += "â€¢ double_mining (2h) - x2 mining rewards (1000 DMT)\n"
            boost_text += "â€¢ triple_gambling (1h) - x3 gambling wins (1500 DMT)\n"
            boost_text += "â€¢ mega_luck (30min) - x5 rzadkie mineraÅ‚y (2000 DMT)\n"
            boost_text += "â€¢ time_master (4h) - 50% szybsze cooldown'y (2500 DMT)\n"
            boost_text += "â€¢ ultimate_power (1h) - WSZYSTKO x3! (5000 DMT)\n\n"

            if active_boosts:
                boost_text += "**AKTYWNE BOOSTY:**\n"
                for boost, end_time in active_boosts.items():
                    if time.time() < end_time:
                        remaining = int(end_time - time.time())
                        boost_text += f"â€¢ {boost}: {remaining//60}m {remaining%60}s\n"
            else:
                boost_text += "**Brak aktywnych boostÃ³w**\n"

            boost_text += "\nUÅ¼yj: `/megaboost [typ]` aby aktywowaÄ‡!"
            await update.message.reply_text(boost_text, parse_mode='Markdown')
            return

        boost_type = context.args[0].lower()
        boost_costs = {
            'double_mining': {'cost': 1000, 'duration': 7200},
            'triple_gambling': {'cost': 1500, 'duration': 3600},
            'mega_luck': {'cost': 2000, 'duration': 1800},
            'time_master': {'cost': 2500, 'duration': 14400},
            'ultimate_power': {'cost': 5000, 'duration': 3600}
        }

        if boost_type not in boost_costs:
            await update.message.reply_text("âŒ Nieznany boost! DostÄ™pne: double_mining, triple_gambling, mega_luck, time_master, ultimate_power")
            return

        cost = boost_costs[boost_type]['cost']
        duration = boost_costs[boost_type]['duration']

        if user_data.get('points', 0) < cost:
            await update.message.reply_text(f"âŒ Potrzebujesz {cost} DMT na ten boost!")
            return

        add_points(user_id, -cost)

        # Aktywuj boost
        active_boosts = user_data.get('active_boosts', {})
        active_boosts[boost_type] = time.time() + duration
        user_data['active_boosts'] = active_boosts
        update_user_data(user_id, user_data)

        await update.message.reply_text(
            f"ğŸš€ **MEGA BOOST AKTYWOWANY!**\n\n"
            f"âš¡ Boost: {boost_type}\n"
            f"â° Czas trwania: {duration//60} minut\n"
            f"ğŸ’¸ Koszt: {cost} DMT\n"
            f"ğŸ’ PozostaÅ‚o: {get_user_points(user_id)} DMT\n\n"
            f"ğŸ”¥ Boost jest teraz aktywny!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w mega_boost: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w mega boost!")

async def god_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Tryb boga dla legends"""
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº czy kwalifikuje siÄ™ do god mode
        points = user_data.get('points', 0)
        respect = user_data.get('mafia_respect', 0)
        special_buildings = user_data.get('special_buildings', [])

        # Wymagania: 100k+ punktÃ³w, Don rang, Forteca Mleka
        if points < 100000:
            await update.message.reply_text(f"âŒ God Mode wymaga 100,000+ punktÃ³w! Masz: {points:,}")
            return

        if get_mafia_rank(respect) != 'Don':
            await update.message.reply_text("âŒ God Mode wymaga rangi Don w mafii!")
            return

        if 'forteca_mleka' not in special_buildings:
            await update.message.reply_text("âŒ God Mode wymaga Forteca Mleka!")
            return

        # SprawdÅº cooldown (24 godziny)
        last_godmode = user_data.get('last_godmode', 0)
        now = time.time()

        if now - last_godmode < 86400:
            remaining = int(86400 - (now - last_godmode))
            hours = remaining // 3600
            minutes = (remaining % 3600) // 60
            await update.message.reply_text(f"âš¡ God Mode dostÄ™pny za {hours}h {minutes}m!")
            return

        # Aktywuj God Mode
        god_rewards = random.randint(25000, 100000)
        mining_levels = random.randint(3, 10)
        respect_bonus = random.randint(1000, 5000)

        # Mega nagrody
        points = add_points(user_id, god_rewards)
        user_data = get_user_data_full(user_id)
        user_data['mining_level'] += mining_levels
        user_data['mafia_respect'] += respect_bonus
        user_data['last_godmode'] = now

        # Resetuj wszystkie cooldown'y
        for location in MINING_LOCATIONS.keys():
            user_data[f'last_mine_{location}'] = 0
        user_data['last_mine'] = 0
        user_data['last_heist'] = 0
        user_data['last_mission'] = 0
        user_data['last_lottery'] = 0

        # Specjalna odznaka
        if check_and_award_badge(user_id, "don_mleko_blessed"):
            badge_text = "\nğŸ… Nowa odznaka: BÅ‚ogosÅ‚awiony przez Dona!"
        else:
            badge_text = ""

        update_user_data(user_id, user_data)

        # Auto-post o god mode
        username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"
        auto_create_achievement_post(user_id, username, 'boss_title', 'GOD MODE ACTIVATED!')

        await update.message.reply_text(
            f"âš¡ğŸ‘‘ **GOD MODE ACTIVATED!** ğŸ‘‘âš¡\n\n"
            f"ğŸŒŸ Don Mleko bÅ‚ogosÅ‚awi CiÄ™!\n\n"
            f"ğŸ **MEGA NAGRODY:**\n"
            f"ğŸ’ +{god_rewards:,} DMT\n"
            f"â›ï¸ +{mining_levels} poziomÃ³w mining\n"
            f"â­ +{respect_bonus:,} szacunku\n"
            f"ğŸ”„ Wszystkie cooldown'y zresetowane\n"
            f"{badge_text}\n\n"
            f"ğŸ† ÅÄ…cznie punktÃ³w: {points:,}\n"
            f"ğŸ‘‘ JesteÅ› prawdziwÄ… legendÄ… rodziny!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w god_mode: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w trybie boga!")

async def my_posts(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """PokaÅ¼ swoje posty"""
    try:
        user_id = update.effective_user.id
        posts = load_social_feed()
        likes = load_post_likes()
        comments = load_post_comments()

        user_posts = [post for post in posts if post['user_id'] == str(user_id)]

        if not user_posts:
            await update.message.reply_text(
                "ğŸ“ **TWOJE POSTY**\n\n"
                "ğŸ” Nie masz jeszcze Å¼adnych postÃ³w!\n\n"
                "ğŸ’¡ UtwÃ³rz pierwszy post:\n"
                "`/post [typ] [tytuÅ‚] [treÅ›Ä‡]`"
            )
            return

        posts_text = f"ğŸ“ **TWOJE POSTY ({len(user_posts)}):**\n\n"

        for post in user_posts[:10]:  # Ostatnie 10
            post_type = POST_TYPES.get(post['type'], 'ğŸ“ Post')
            time_ago = get_time_ago(post['timestamp'])

            posts_text += (
                f"ğŸ†” {post['id'][-8:]} | {post_type}\n"
                f"ğŸ“ **{post['title']}**\n"
                f"ğŸ•’ {time_ago}\n"
                f"ğŸ‘ {len(likes.get(post['id'], []))} â€¢ ğŸ’¬ {len(comments.get(post['id'], []))}\n\n"
            )

        if len(user_posts) > 10:
            posts_text += f"... i {len(user_posts) - 10} wiÄ™cej postÃ³w"

        await update.message.reply_text(posts_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w my_posts: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d podczas pobierania Twoich postÃ³w!")

# === CALLBACK HANDLERS ===
async def territory(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "territory")
        if not can_proceed:
            await update.message.reply_text(f"âŒ {message}")
            return

        if not context.args:
            territory_owned = user_data.get('territory_owned', 0)
            user_points = user_data.get('points', 0)

            territories_text = "ğŸ° **DOSTÄ˜PNE TERYTORIUM:**\n\n"
            territories_text += f"ğŸ’ Twoje punkty: {user_points} DMT\n"
            territories_text += f"ğŸ˜ï¸ Posiadasz: {territory_owned}/{len(TERRITORIES)} terytorium\n\n"

            total_income = 0

            # PokaÅ¼ wszystkie terytoria - grupowane dla lepszej czytelnoÅ›ci
            territories_text += "ğŸ“‹ **WSZYSTKIE TERYTORIA:**\n\n"

            # Podziel na grupy po 5 dla lepszej czytelnoÅ›ci
            for i, territory in enumerate(TERRITORIES, 1):
                if i <= territory_owned:
                    status = "âœ… POSIADANE"
                    total_income += territory['income']
                    status_emoji = "âœ…"
                elif i == territory_owned + 1:
                    if user_points >= territory['cost']:
                        status = f"ğŸ’š MOÅ»ESZ KUPIÄ†"
                        status_emoji = "ğŸ’š"
                    else:
                        status = f"ğŸ’° POTRZEBUJESZ {territory['cost'] - user_points:,} DMT"
                        status_emoji = "ğŸ’°"
                else:
                    status = f"ğŸ”’ ZABLOKOWANE"
                    status_emoji = "ğŸ”’"

                territories_text += (
                    f"{status_emoji} {i}. **{territory['name']}**\n"
                    f"   ğŸ¢ {territory['type']} | ğŸ’° {territory['cost']:,} DMT | ğŸ“ˆ +{territory['income']} DMT/h\n"
                    f"   ğŸ“Š {status}\n\n"
                )

                # Dodaj separator co 10 terytorii dla lepszej czytelnoÅ›ci
                if i % 10 == 0 and i < len(TERRITORIES):
                    territories_text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"

            territories_text += f"ğŸ’° **ÅÄ…czny dochÃ³d:** {total_income} DMT/h\n\n"

            # Instrukcje
            if territory_owned < len(TERRITORIES):
                next_territory = TERRITORIES[territory_owned]
                territories_text += f"ğŸ¯ **NASTÄ˜PNE DO KUPIENIA:**\n"
                territories_text += f"   {territory_owned + 1}. {next_territory['name']} - {next_territory['cost']} DMT\n\n"
            else:
                territories_text += "ğŸ‰ **GRATULACJE!** Posiadasz wszystkie terytoria!\n\n"

            territories_text += "UÅ¼yj: `/territory [numer]` aby kupiÄ‡ terytorium\n"
            territories_text += "ğŸ’¡ Terytoria kupujesz po kolei!"

            await update.message.reply_text(territories_text, parse_mode='Markdown')
            return

        try:
            territory_id = int(context.args[0]) - 1
            if territory_id < 0 or territory_id >= len(TERRITORIES):
                raise ValueError
        except ValueError:
            await update.message.reply_text(f"âŒ Podaj prawidÅ‚owy numer terytorium (1-{len(TERRITORIES)})!")
            return

        territory_owned = user_data.get('territory_owned', 0)

        if territory_id < territory_owned:
            await update.message.reply_text("âŒ To terytorium juÅ¼ posiadasz!")
            return

        if territory_id != territory_owned:
            await update.message.reply_text("âŒ Musisz kupowaÄ‡ terytorium po kolei!")
            return

        territory = TERRITORIES[territory_id]
        points = user_data.get('points', 0)

        if points < territory['cost']:
            await update.message.reply_text(f"âŒ Potrzebujesz {territory['cost']} DMT aby kupiÄ‡ {territory['name']}!\nğŸ’ Masz: {points} DMT")
            return

        # Kup terytorium - odejmij koszt TYLKO JEDEN RAZ
        final_points = add_points(user_id, -territory['cost'])

        # Zaktualizuj dane terytorium
        updated_user_data = get_user_data_full(user_id)  # Pobierz Å›wieÅ¼e dane
        updated_user_data['territory_owned'] = territory_owned + 1
        updated_user_data['last_territory_income'] = time.time()
        update_user_data(user_id, updated_user_data)

        # Pobierz aktualne punkty po zakupie (juÅ¼ sÄ… poprawne z add_points)
        new_points = final_points

        # SprawdÅº odznakÄ™
        if user_data['territory_owned'] >= 3:
            check_and_award_badge(user_id, "territory_king")

        total_income = sum(TERRITORIES[i]['income'] for i in range(user_data['territory_owned']))

        await update.message.reply_text(
            f"ğŸ° **TERYTORIUM ZDOBYTE!**\n\n"
            f"ğŸ“ Kupiono: **{territory['name']}**\n"
            f"ğŸ¢ Typ: {territory['type']}\n"
            f"ğŸ’¸ Koszt: {territory['cost']} DMT\n"
            f"ğŸ“ˆ Nowy dochÃ³d: +{territory['income']} DMT/h\n"
            f"ğŸ’° ÅÄ…czny dochÃ³d: {total_income} DMT/h\n"
            f"ğŸ’ PozostaÅ‚o punktÃ³w: {new_points}\n\n"
            f"ğŸ° Posiadasz {user_data['territory_owned']}/{len(TERRITORIES)} terytorium!\n\n"
            f"ğŸ’¡ MoÅ¼esz teraz zbieraÄ‡ haracze co godzinÄ™!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w territory: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie terytorium!")

async def protection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "protection")
        if not can_proceed:
            await update.message.reply_text(f"âŒ {message}")
            return

        territory_owned = user_data.get('territory_owned', 0)

        if territory_owned == 0:
            await update.message.reply_text(
                "âŒ **BRAK TERYTORIUM!**\n\n"
                "ğŸ° Musisz posiadaÄ‡ terytorium aby zbieraÄ‡ haracze!\n\n"
                "ğŸ’¡ **JAK ZDOBYÄ† TERYTORIUM:**\n"
                "ğŸ“ `/territory` - zobacz dostÄ™pne tereny\n"
                "ğŸ“ `/territory 1` - kup pierwszÄ… dzielnicÄ™ (500 DMT)\n\n"
                "ğŸ¯ **KORZYÅšCI:**\n"
                "â€¢ Pasywny dochÃ³d co godzinÄ™\n"
                "â€¢ Bonus za rangÄ™ mafijnÄ…\n"
                "â€¢ MoÅ¼liwoÅ›Ä‡ budowy specjalnych budynkÃ³w"
            )
            return

        # Inicjalizuj last_territory_income jeÅ›li nie istnieje
        if 'last_territory_income' not in user_data:
            user_data['last_territory_income'] = time.time()
            update_user_data(user_id, user_data)

        last_collection = user_data.get('last_territory_income', time.time())
        now = time.time()
        hours_passed = (now - last_collection) / 3600

        # Minimalno 1 godzina miÄ™dzy zbiorami
        if hours_passed < 1.0:
            remaining = int(3600 - (now - last_collection))
            minutes = remaining // 60
            seconds = remaining % 60
            await update.message.reply_text(
                f"â° **ZBYT WCZEÅšNIE!**\n\n"
                f" Czas akumulacji: {int(hours_passed)}h\n"
                f"ğŸ”¸ NastÄ™pny haracz za: {minutes}m {seconds}s\n\n"
                f"ğŸ° Twoje terytorium: {territory_owned}/{len(TERRITORIES)}\n"
                f"ğŸ’° DochÃ³d/godzina: {sum(TERRITORIES[i]['income'] for i in range(territory_owned))} DMT"
            )
            return

        # Oblicz dochÃ³d
        hourly_income = sum(TERRITORIES[i]['income'] for i in range(territory_owned))
        max_hours = min(24, int(hours_passed))  # Maksymalnie 24h akumulacji
        base_income = hourly_income * max_hours

        # Dodaj bonus za rangÄ™ mafijnÄ…
        respect = user_data.get('mafia_respect', 0)
        rank = get_mafia_rank(respect)
        bonus_percent = MAFIA_RANKS[rank]['bonus']
        bonus_income = int(base_income * bonus_percent / 100)
        total_income = base_income + bonus_income

        # Dodaj bonusy z budynkÃ³w specjalnych
        special_buildings = user_data.get('special_buildings', [])
        building_bonus = 0

        if 'cyber_centrum' in special_buildings:
            building_bonus += int(total_income * 0.4)  # +40%
        if 'rakieta_don_mleko' in special_buildings:
            building_bonus += int(total_income * 1.0)  # +100%
        if 'forteca_mleka' in special_buildings:
            building_bonus += int(total_income * 0.5)  # +50%

        final_income = total_income + building_bonus

        # Dodaj punkty i zaktualizuj dane
        points = add_points(user_id, final_income)

        # Zaktualizuj dane haraczy
        user_data['last_territory_income'] = now
        user_data['protection_money'] = user_data.get('protection_money', 0) + final_income
        update_user_data(user_id, user_data)

        # Przygotuj tekst wyniku
        result_text = (
            f"ğŸ’° **HARACZE ZEBRANE!**\n\n"
            f"ğŸ° Terytorium: {territory_owned}/{len(TERRITORIES)}\n"
            f"â° Czas akumulacji: {max_hours}h\n"
            f"ğŸ“Š DochÃ³d bazowy: {hourly_income}/h Ã— {max_hours}h = {base_income} DMT\n"
        )

        if bonus_income > 0:
            result_text += f"ğŸ‘‘ Bonus za rangÄ™ ({rank}): +{bonus_income} DMT\n"

        if building_bonus > 0:
            result_text += f"ğŸ—ï¸ Bonus z budynkÃ³w: +{building_bonus} DMT\n"

        result_text += (
            f"ğŸ’ **ÅÄ„CZNIE: {final_income} DMT**\n"
            f"ğŸ¦ Masz teraz: {points} punktÃ³w\n"
            f"ğŸ“ˆ CaÅ‚kowite haracze: {user_data['protection_money']:,} DMT\n\n"
            f"ğŸ¤µ NastÄ™pny zbiÃ³r za 1 godzinÄ™!"
        )

        await update.message.reply_text(result_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w protection: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie haraczy! SprÃ³buj ponownie za chwilÄ™.")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        user_data = get_user_data_full(user_id)

        if query.data == "missions":
            user_data = get_user_data_full(user_id)
            last_mission = user_data.get('last_mission', 0)
            now = time.time()
            respect = user_data.get('mafia_respect', 0)
            rank = get_mafia_rank(respect)
            user_points = user_data.get('points', 0)

            missions_text = "ğŸ¯ **DOSTÄ˜PNE MISJE MAFII:**\n\n"
            missions_text += f"ğŸ‘¤ Twoja ranga: {rank}\n"
            missions_text += f"ğŸ’ Twoje punkty: {user_points} DMT\n"
            missions_text += f"â­ Szacunek: {respect}\n\n"

            if now - last_mission < 1800:  # 30 minut cooldown
                remaining = int(1800 - (now - last_mission))
                missions_text += f"â° NastÄ™pna misja za {remaining//60}m {remaining%60}s!\n\n"

            # Podziel misje na grupy po trudnoÅ›ci
            missions_by_difficulty = {
                'Åatwe': [],
                'Åšrednie': [],
                'Trudne': [],
                'Eksperckie': []
            }

            for i, mission in enumerate(MISSIONS, 1):
                success_bonus = MAFIA_RANKS[rank]['bonus']
                base_chance = {
                    'Å‚atwy': 80,
                    'Å›redni': 60,
                    'trudny': 40,
                    'bardzo trudny': 20,
                    'ekspert': 15,
                    'legendarna': 10,
                    'mityczna': 5,
                    'boski': 3,
                    'transcendentny': 1
                }
                success_chance = min(95, base_chance.get(mission['difficulty'], 50) + success_bonus)

                if mission['difficulty'] in ['Å‚atwy']:
                    category = 'Åatwe'
                elif mission['difficulty'] in ['Å›redni']:
                    category = 'Åšrednie'
                elif mission['difficulty'] in ['trudny', 'bardzo trudny']:
                    category = 'Trudne'
                else:
                    category = 'Eksperckie'

                missions_by_difficulty[category].append((i, mission, success_chance))

            # UtwÃ³rz przyciski dla kategorii misji
            keyboard = []

            # Dodaj przyciski kategorii misji
            if missions_by_difficulty['Åatwe']:
                keyboard.append([InlineKeyboardButton(
                    f"ğŸŸ¢ Misje Åatwe ({len(missions_by_difficulty['Åatwe'])})",
                    callback_data="missions_easy"
                )])

            if missions_by_difficulty['Åšrednie']:
                keyboard.append([InlineKeyboardButton(
                    f"ğŸŸ¡ Misje Åšrednie ({len(missions_by_difficulty['Åšrednie'])})",
                    callback_data="missions_medium"
                )])

            if missions_by_difficulty['Trudne']:
                keyboard.append([InlineKeyboardButton(
                    f"ğŸŸ  Misje Trudne ({len(missions_by_difficulty['Trudne'])})",
                    callback_data="missions_hard"
                )])

            if missions_by_difficulty['Eksperckie']:
                keyboard.append([InlineKeyboardButton(
                    f"ğŸ”´ Misje Eksperckie ({len(missions_by_difficulty['Eksperckie'])})",
                    callback_data="missions_expert"
                )])

            # Przycisk powrotu
            keyboard.append([InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")])

            missions_text += (
                "ğŸ“‹ **Wybierz kategoriÄ™ misji:**\n\n"
                "ğŸŸ¢ **Åatwe** - Wysokie szanse powodzenia\n"
                "ğŸŸ¡ **Åšrednie** - Umiarkowane ryzyko\n"
                "ğŸŸ  **Trudne** - Wysokie ryzyko, wysokie nagrody\n"
                "ğŸ”´ **Eksperckie** - Ekstremalnie trudne, legendarne nagrody\n\n"
                "ğŸ’¡ Twoja ranga wpÅ‚ywa na szanse powodzenia!"
            )

            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                missions_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        elif query.data == "territory":
            territory_owned = user_data.get('territory_owned', 0)
            total_income = sum(TERRITORIES[i]['income'] for i in range(territory_owned)) if territory_owned > 0 else 0
            user_points = user_data.get('points', 0)

            # PokaÅ¼ pierwsze 5 terytorium z opcjami kupna
            territory_text = f"ğŸ° **SYSTEM TERYTORIUM**\n\n"
            territory_text += f"ğŸ“ Posiadasz: {territory_owned}/{len(TERRITORIES)} terytorium\n"
            territory_text += f"ğŸ’° DochÃ³d: {total_income} DMT/godzina\n"
            territory_text += f"ğŸ’ Twoje punkty: {user_points} DMT\n\n"

            territory_text += "**DOSTÄ˜PNE TERYTORIUM:**\n"

            # Przyciski dla terytorium
            keyboard = []

            # PokaÅ¼ nastÄ™pne 3 dostÄ™pne terytoria
            for i in range(territory_owned, min(territory_owned + 3, len(TERRITORIES))):
                territory = TERRITORIES[i]
                if user_points >= territory['cost']:
                    status = f"âœ… Kup za {territory['cost']} DMT"
                    keyboard.append([InlineKeyboardButton(
                        f"ğŸ¢ {territory['name']} ({territory['cost']} DMT)",
                        callback_data=f"buy_territory_{i}"
                    )])
                else:
                    status = f"âŒ Potrzebujesz {territory['cost']} DMT"

                territory_text += (
                    f"{i+1}. **{territory['name']}**\n"
                    f"   ğŸ’° Koszt: {territory['cost']} DMT\n"
                    f"   ğŸ“ˆ DochÃ³d: +{territory['income']} DMT/h\n"
                    f"   ğŸ“Š Status: {status}\n\n"
                )

            # Dodaj przyciski nawigacyjne
            if territory_owned > 0:
                keyboard.append([InlineKeyboardButton("ğŸ›¡ï¸ Zbierz Haracze", callback_data="protection")])

            keyboard.append([InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")])

            reply_markup = InlineKeyboardMarkup(keyboard)

            if territory_owned >= len(TERRITORIES):
                territory_text += "ğŸ‘‘ **GRATULACJE! Posiadasz caÅ‚e miasto!**"
            else:
                territory_text += f"ğŸ’¡ **Informacja:** Terytorium kupujesz po kolei.\n"
                territory_text += f"ğŸ¯ NastÄ™pne: {TERRITORIES[territory_owned]['name']} za {TERRITORIES[territory_owned]['cost']} DMT"

            await query.edit_message_text(
                territory_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        elif query.data == "heist":
            last_heist = user_data.get('last_heist', 0)
            now = time.time()

            if now - last_heist < 3600:
                remaining = int(3600 - (now - last_heist))
                await query.edit_message_text(
                    f"ğŸ’° **SYSTEM NAPADÃ“W**\n\n"
                    f"â° NastÄ™pny napad za: {remaining//60}m {remaining%60}s\n\n"
                    f"ğŸ’¸ Koszt przygotowania: 100 DMT\n"
                    f"ğŸ’° Potencjalna nagroda: 500-2000 DMT\n"
                    f"â­ Szacunek za udany napad: +75\n\n"
                    f"ğŸ¯ Szanse zaleÅ¼Ä… od Twojej rangi w mafii!",
                    parse_mode='Markdown'
                )
            else:
                await query.edit_message_text(
                    f"ğŸ’° **SYSTEM NAPADÃ“W**\n\n"
                    f"âœ… Napad dostÄ™pny!\n\n"
                    f"ğŸ’¸ Koszt przygotowania: 100 DMT\n"
                    f"ğŸ’° Potencjalna nagroda: 500-2000 DMT\n"
                    f"â­ Szacunek za udany napad: +75\n\n"
                    f"UÅ¼yj: `/heist` aby rozpoczÄ…Ä‡ napad!",
                    parse_mode='Markdown'
                )

        elif query.data == "protection":
            territory_owned = user_data.get('territory_owned', 0)

            if territory_owned == 0:
                keyboard = [[InlineKeyboardButton("ğŸ° Zobacz Terytorium", callback_data="territory")]]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await query.edit_message_text(
                    f"ğŸ›¡ï¸ **SYSTEM HARACZY**\n\n"
                    f"âŒ Nie posiadasz Å¼adnego terytorium!\n\n"
                    f"ğŸ° Musisz kupiÄ‡ terytorium aby zbieraÄ‡ haracze\n"
                    f"ğŸ’¡ Pierwsze terytorium kosztuje 500 DMT\n"
                    f"ğŸ“ˆ Daje pasywny dochÃ³d co godzinÄ™!\n\n"
                    f"ğŸ‘‡ Kliknij przycisk poniÅ¼ej:",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
            else:
                last_collection = user_data.get('last_territory_income', time.time())
                now = time.time()
                hours_passed = (now - last_collection) / 3600
                hourly_income = sum(TERRITORIES[i]['income'] for i in range(territory_owned))

                # Dodaj przyciski akcji
                if hours_passed >= 1:
                    potential_income = int(hourly_income * min(24, int(hours_passed)))
                    keyboard = [
                        [InlineKeyboardButton("ğŸ’° Zbierz Haracze", callback_data="collect_protection")],
                        [InlineKeyboardButton("ğŸ° Zobacz Terytorium", callback_data="territory")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)

                    await query.edit_message_text(
                        f"ğŸ›¡ï¸ **SYSTEM HARACZY**\n\n"
                        f"âœ… Haracze dostÄ™pne!\n\n"
                        f"ğŸ° Terytorium: {territory_owned}/{len(TERRITORIES)}\n"
                        f"ğŸ’° DochÃ³d: {hourly_income} DMT/h\n"
                        f"â° Czas akumulacji: {int(hours_passed)}h\n"
                        f"ğŸ’ Do zebrania: ~{potential_income} DMT\n\n"
                        f"ğŸ‘‡ Kliknij aby zebraÄ‡:",
                        reply_markup=reply_markup,
                        parse_mode='Markdown'
                    )
                else:
                    remaining = int(3600 - (now - last_collection))
                    keyboard = [[InlineKeyboardButton("ğŸ° Zobacz Terytorium", callback_data="territory")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)

                    await query.edit_message_text(
                        f"ğŸ›¡ï¸ **SYSTEM HARACZY**\n\n"
                        f"â° NastÄ™pne haracze za: {remaining//60}m {remaining%60}s\n\n"
                        f"ğŸ° Terytorium: {territory_owned}/{len(TERRITORIES)}\n"
                        f"ğŸ’° DochÃ³d: {hourly_income} DMT/h\n\n"
                        f"ğŸ’¡ Haracze moÅ¼na zbieraÄ‡ co godzinÄ™!",
                        reply_markup=reply_markup,
                        parse_mode='Markdown'
                    )

        elif query.data == "recruitment":
            recruited = user_data.get('recruited_members', [])
            recruited_by = user_data.get('recruited_by', None)
            user_rank = get_mafia_rank(user_data.get('mafia_respect', 0))

            recruitment_text = "ğŸ‘¥ **SYSTEM WERBOWANIA**\n\n"

            if can_recruit(user_id):
                bonus = get_recruitment_bonus(user_rank)
                recruitment_text += (
                    f"âœ… MoÅ¼esz werbowaÄ‡ nowych czÅ‚onkÃ³w!\n"
                    f"ğŸ’° Bonus za werbowanie: {bonus} DMT\n"
                    f"ğŸ¯ Zwerbowani przez Ciebie: {len(recruited)}\n\n"
                    f"**INSTRUKCJA:**\n"
                    f"Nowy gracz: `/recruit {update.effective_user.username or user_id}`\n\n"
                )
            else:
                recruitment_text += (
                    f"âŒ Potrzebujesz rangi Capo aby werbowaÄ‡\n"
                    f"ğŸ“ˆ Wymagane: 300+ szacunek\n\n"
                )

            if recruited_by:
                recruitment_text += f"ğŸ‘¤ ZostaÅ‚eÅ› zwerbowany przez: {recruited_by}\n"

            recruitment_text += f"ğŸ¤µ UÅ¼yj: `/recruit` aby zobaczyÄ‡ wiÄ™cej"

            await query.edit_message_text(recruitment_text, parse_mode='Markdown')

        elif query.data == "chat":
            channels = user_data.get('chat_channels', ['rodzina'])
            messages_count = user_data.get('message_count', 0)

            chat_text = "ğŸ’¬ **SYSTEM KOMUNIKACJI**\n\n"
            chat_text += f"ğŸ“± DostÄ™pne kanaÅ‚y: {len(channels)}\n"
            chat_text += f"ğŸ’­ WysÅ‚ane wiadomoÅ›ci: {messages_count}\n\n"

            chat_text += "**TWOJE KANAÅY:**\n"
            for channel in channels:
                if channel in CHAT_CHANNELS:
                    chat_text += f"â€¢ {CHAT_CHANNELS[channel]['name']}\n"

            chat_text += (
                f"\n**INSTRUKCJA:**\n"
                f"ğŸ“ `/chat [kanaÅ‚] [wiadomoÅ›Ä‡]` - wyÅ›lij wiadomoÅ›Ä‡\n"
                f"ğŸ‘€ `/chat [kanaÅ‚]` - zobacz wiadomoÅ›ci\n"
                f"ğŸ“‹ `/chat` - lista kanaÅ‚Ã³w"
            )

            await query.edit_message_text(chat_text, parse_mode='Markdown')

        elif query.data == "bosses":
            bosses_text = "ğŸ‘‘ **BOSSOWIE MAFII**\n\n"

            for boss_id, boss_info in MAFIA_BOSSES.items():
                bosses_text += f"{boss_info['name']} - {boss_info['title']}\n"

            bosses_text += (
                f"\n**HIERARCHIA:**\n"
                f"ğŸ„ Don Mleko (Boss wszystkich bossÃ³w)\n"
                f"ğŸ¦Œ BiaÅ‚y Rogacz (Prawa rÄ™ka)\n"
                f"ğŸ©¸ğŸ„ Krwawa Krowa (Egzekutor)\n"
                f"ğŸ‘» Milk Phantom (Szpieg)\n\n"
                f"ğŸ¯ UÅ¼yj: `/bosses` aby zobaczyÄ‡ szczegÃ³Å‚y"
            )

            await query.edit_message_text(bosses_text, parse_mode='Markdown')

        elif query.data == "collect_protection":
            # Wykonaj zbieranie haraczy przez przycisk
            territory_owned = user_data.get('territory_owned', 0)

            if territory_owned == 0:
                await query.answer("âŒ Nie masz terytorium!", show_alert=True)
                return

            last_collection = user_data.get('last_territory_income', time.time())
            now = time.time()
            hours_passed = (now - last_collection) / 3600

            if hours_passed < 1.0:
                remaining = int(3600 - (now - last_collection))
                await query.answer(f"â° Musisz poczekaÄ‡ {remaining//60}m {remaining%60}s!", show_alert=True)
                return

            # Oblicz dochÃ³d (podobnie jak w funkcji protection)
            hourly_income = sum(TERRITORIES[i]['income'] for i in range(territory_owned))
            max_hours = min(24, int(hours_passed))
            base_income = hourly_income * max_hours

            # Bonus za rangÄ™ mafijnÄ…
            respect = user_data.get('mafia_respect', 0)
            rank = get_mafia_rank(respect)
            bonus_percent = MAFIA_RANKS[rank]['bonus']
            bonus_income = int(base_income * bonus_percent / 100)
            total_income = base_income + bonus_income

            # Bonusy z budynkÃ³w specjalnych
            special_buildings = user_data.get('special_buildings', [])
            building_bonus = 0

            if 'cyber_centrum' in special_buildings:
                building_bonus += int(total_income * 0.4)
            if 'rakieta_don_mleko' in special_buildings:
                building_bonus += int(total_income * 1.0)
            if 'forteca_mleka' in special_buildings:
                building_bonus += int(total_income * 0.5)

            final_income = total_income + building_bonus

            # Dodaj punkty i zaktualizuj dane
            points = add_points(user_id, final_income)

            user_data['last_territory_income'] = now
            user_data['protection_money'] = user_data.get('protection_money', 0) + final_income
            update_user_data(user_id, user_data)

            # PokaÅ¼ wynik
            keyboard = [
                [InlineKeyboardButton("ğŸ° Zobacz Terytorium", callback_data="territory")],
                [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                f"ğŸ’° **HARACZE ZEBRANE!**\n\n"
                f"ğŸ° Terytorium: {territory_owned}/{len(TERRITORIES)}\n"
                f"â° Czas akumulacji: {max_hours}h\n"
                f"ğŸ“Š DochÃ³d bazowy: {base_income} DMT\n" +
                (f"ğŸ‘‘ Bonus za rangÄ™ ({rank}): +{bonus_income} DMT\n" if bonus_income > 0 else "") +
                (f"ğŸ—ï¸ Bonus z budynkÃ³w: +{building_bonus} DMT\n" if building_bonus > 0 else "") +
                f"ğŸ’ **ÅÄ„CZNIE: {final_income} DMT**\n"
                f"ğŸ¦ Masz teraz: {points} punktÃ³w\n\n"
                f"ğŸ¤µ NastÄ™pny zbiÃ³r za 1 godzinÄ™!",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        elif query.data.startswith("buy_territory_"):
            # ObsÅ‚uga kupna terytorium przez przycisk
            try:
                territory_id = int(query.data.split("_")[-1])
            except ValueError:
                await query.answer("âŒ BÅ‚Ä…d w ID terytorium!", show_alert=True)
                return

            territory_owned = user_data.get('territory_owned', 0)
            user_points = user_data.get('points', 0)

            # SprawdÅº czy moÅ¼e kupiÄ‡ to terytorium
            if territory_id != territory_owned:
                await query.answer("âŒ Musisz kupowaÄ‡ terytorium po kolei!", show_alert=True)
                return

            if territory_id >= len(TERRITORIES):
                await query.answer("âŒ NieprawidÅ‚owe terytorium!", show_alert=True)
                return

            territory = TERRITORIES[territory_id]

            if user_points < territory['cost']:
                await query.answer(f"âŒ Potrzebujesz {territory['cost']} DMT!", show_alert=True)
                return

            # Kup terytorium - odejmij koszt TYLKO JEDEN RAZ
            final_points = add_points(user_id, -territory['cost'])

            # Zaktualizuj dane uÅ¼ywajÄ…c Å›wieÅ¼ych danych
            fresh_user_data = get_user_data_full(user_id)
            fresh_user_data['territory_owned'] = territory_owned + 1
            fresh_user_data['last_territory_income'] = time.time()
            update_user_data(user_id, fresh_user_data)

            # Pobierz aktualne punkty po zakupie (juÅ¼ sÄ… poprawne)
            new_points = final_points

            # SprawdÅº odznakÄ™
            if user_data['territory_owned'] >= 3:
                check_and_award_badge(user_id, "territory_king")

            total_income = sum(TERRITORIES[i]['income'] for i in range(user_data['territory_owned']))

            # PokaÅ¼ wynik zakupu
            keyboard = [
                [InlineKeyboardButton("ğŸ° Zobacz Terytorium", callback_data="territory")],
                [InlineKeyboardButton("ğŸ›¡ï¸ Zbierz Haracze", callback_data="protection")],
                [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                f"ğŸ° **TERYTORIUM ZDOBYTE!**\n\n"
                f"ğŸ“ Kupiono: **{territory['name']}**\n"
                f"ğŸ¢ Typ: {territory['type']}\n"
                f"ğŸ’¸ Koszt: {territory['cost']} DMT\n"
                f"ğŸ“ˆ Nowy dochÃ³d: +{territory['income']} DMT/h\n"
                f"ğŸ’° ÅÄ…czny dochÃ³d: {total_income} DMT/h\n"
                f"ğŸ’ PozostaÅ‚o punktÃ³w: {new_points}\n\n"
                f"ğŸ° Posiadasz {user_data['territory_owned']}/{len(TERRITORIES)} terytorium!\n\n"
                f"ğŸ’¡ MoÅ¼esz teraz zbieraÄ‡ haracze co godzinÄ™!",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        elif query.data == "back_to_mafia":
            # PowrÃ³t do gÅ‚Ã³wnego menu mafii
            respect = user_data.get('mafia_respect', 0)
            rank = get_mafia_rank(respect)

            keyboard = [
                [InlineKeyboardButton("ğŸ¯ Misje", callback_data="missions")],
                [InlineKeyboardButton("ğŸ° Terytorium", callback_data="territory")],
                [InlineKeyboardButton("ğŸ’° Napad", callback_data="heist")],
                [InlineKeyboardButton("ğŸ›¡ï¸ Haracze", callback_data="protection")],
                [InlineKeyboardButton("ğŸ‘¥ Werbowanie", callback_data="recruitment"), InlineKeyboardButton("ğŸ’¬ Czat", callback_data="chat")],
                [InlineKeyboardButton("ğŸ² Gry Mafii", callback_data="mafia_games")],
                [InlineKeyboardButton("ğŸ‘‘ Bossowie", callback_data="bosses")],
                [InlineKeyboardButton("ğŸ“Š Status mafii", callback_data="mafia_status")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                f"ğŸ¤µ **RODZINA MAFII DON MLEKO**\n\n"
                f"ğŸ‘¤ Twoja ranga: **{rank}**\n"
                f"â­ Szacunek: {respect}\n"
                f"ğŸ’° Bonus za rangÄ™: +{MAFIA_RANKS[rank]['bonus']}%\n\n"
                f"ğŸ¯ Wybierz akcjÄ™:",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        elif query.data == "mafia_status":
            respect = user_data.get('mafia_respect', 0)
            rank = get_mafia_rank(respect)
            contracts = user_data.get('contracts_completed', 0)
            territory = user_data.get('territory_owned', 0)
            total_protection = user_data.get('protection_money', 0)
            recruited = len(user_data.get('recruited_members', []))
            messages = user_data.get('message_count', 0)

            await query.edit_message_text(
                f"ğŸ“Š **TWÃ“J STATUS W MAFII**\n\n"
                f"ğŸ‘¤ Ranga: **{rank}**\n"
                f"â­ Szacunek: {respect}\n"
                f"ğŸ¯ Wykonane kontrakty: {contracts}\n"
                f"ğŸ° Posiadane terytorium: {territory}/{len(TERRITORIES)}\n"
                f"ğŸ’° ÅÄ…czne haracze: {total_protection} DMT\n"
                f"ğŸ‘¥ Zwerbowani czÅ‚onkowie: {recruited}\n"
                f"ğŸ’¬ WysÅ‚ane wiadomoÅ›ci: {messages}\n"
                f"ğŸ”¥ Bonus za rangÄ™: +{MAFIA_RANKS[rank]['bonus']}%\n\n"
                f"ğŸ’¡ Im wyÅ¼sza ranga, tym wiÄ™ksze szanse w misjach!",
                parse_mode='Markdown'
            )

        elif query.data == "mafia_games":
            # Menu gier mafii
            user_points = user_data.get('points', 0)

            games_text = (
                f"ğŸ² **GIER MAFII DON MLEKO**\n\n"
                f"ğŸ’ Twoje punkty: {user_points} DMT\n\n"
                f"**DOSTÄ˜PNE GIER:**\n"
                f"ğŸƒ **Blackjack** - Klasyczna gra 21\n"
                f"ğŸ² **KoÅ›ci** - Zgadnij sumÄ™ koÅ›ci\n"
                f"ğŸš€ **Crash** - Rakieta do gwiazd\n"
                f"ğŸ¡ **KoÅ‚o Fortuny** - Mega jackpoty\n\n"
                f"ğŸ¤µ **Bonusy mafijne aktywne!**"
            )

            keyboard = [
                [InlineKeyboardButton("ğŸƒ Blackjack", callback_data="game_blackjack")],
                [InlineKeyboardButton("ğŸ² KoÅ›ci", callback_data="game_dice")],
                [InlineKeyboardButton("ğŸš€ Crash Game", callback_data="game_crash")],
                [InlineKeyboardButton("ğŸ¡ KoÅ‚o Fortuny", callback_data="game_wheel")],
                [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await query.edit_message_text(
                games_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

        # Handlery dla kategorii misji
        elif query.data == "missions_easy":
            await show_missions_category(query, user_data, "easy", "ğŸŸ¢ MISJE ÅATWE")
        elif query.data == "missions_medium":
            await show_missions_category(query, user_data, "medium", "ğŸŸ¡ MISJE ÅšREDNIE")
        elif query.data == "missions_hard":
            await show_missions_category(query, user_data, "hard", "ğŸŸ  MISJE TRUDNE")
        elif query.data == "missions_expert":
            await show_missions_category(query, user_data, "expert", "ğŸ”´ MISJE EKSPERCKIE")

        # Nowy handler dla start_mission_X
        elif query.data.startswith("start_mission_"):
            try:
                mission_index = int(query.data.split("_")[-1]) - 1  # Poprawka: -1 bo misje sÄ… indeksowane od 1
                if mission_index < 0 or mission_index >= len(MISSIONS):
                    raise ValueError
            except ValueError:
                await query.answer("âŒ BÅ‚Ä…d w ID misji!", show_alert=True)
                return

            mission = MISSIONS[mission_index]

            # SprawdÅº cooldown misji
            last_mission = user_data.get('last_mission', 0)
            now = time.time()
            if now - last_mission < 1800:  # 30 minut cooldown
                remaining = int(1800 - (now - last_mission))
                await query.answer(f"â° NastÄ™pna misja za {remaining//60}m {remaining%60}s!", show_alert=True)
                return

            # Symulacja misji (tak jak w komendzie /missions)
            respect = user_data.get('mafia_respect', 0)
            rank = get_mafia_rank(respect)
            success_bonus = MAFIA_RANKS[rank]['bonus']
            base_chance = {
                'Å‚atwy': 80, 'Å›redni': 60, 'trudny': 40, 'bardzo trudny': 20,
                'ekspert': 15, 'legendarna': 10, 'mityczna': 5, 'boski': 3, 'transcendentny': 1
            }
            success_chance = min(95, base_chance.get(mission['difficulty'], 50) + success_bonus)

            if random.randint(1, 100) <= success_chance:
                reward = random.randint(*mission['reward'])
                respect_gain = mission['respect']
                points = add_points(user_id, reward)

                user_data = get_user_data_full(user_id) # OdÅ›wieÅ¼ dane
                old_rank = get_mafia_rank(user_data.get('mafia_respect', 0))
                user_data['mafia_respect'] = user_data.get('mafia_respect', 0) + respect_gain
                user_data['last_mission'] = now
                user_data['contracts_completed'] = user_data.get('contracts_completed', 0) + 1
                update_user_data(user_id, user_data)

                new_rank = get_mafia_rank(user_data['mafia_respect'])

                if user_data['contracts_completed'] >= 5:
                    check_and_award_badge(user_id, "contract_killer")
                if new_rank == 'Don':
                    check_and_award_badge(user_id, "mafia_boss")

                rank_text = f"\nğŸ‰ AWANS! Nowa ranga: **{new_rank}**!" if new_rank != old_rank else ""

                # Przyciski po udanej misji
                keyboard = [
                    [InlineKeyboardButton("ğŸ¯ PowrÃ³t do Misji", callback_data="missions")],
                    [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await query.edit_message_text(
                    f"âœ… **MISJA UDANA!**\n\n"
                    f"ğŸ¯ {mission['name']}\n"
                    f"ğŸ’° Nagroda: +{reward} DMT\n"
                    f"â­ Szacunek: +{respect_gain}\n"
                    f"ğŸ’ ÅÄ…cznie punktÃ³w: {points}{rank_text}\n\n"
                    f"ğŸ‘¤ Ranga: {new_rank} (szacunek: {user_data['mafia_respect']})",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
            else:
                user_data['last_mission'] = now
                update_user_data(user_id, user_data)

                # Przyciski po nieudanej misji
                keyboard = [
                    [InlineKeyboardButton("ğŸ¯ PowrÃ³t do Misji", callback_data="missions")],
                    [InlineKeyboardButton("ğŸ”™ PowrÃ³t do Mafii", callback_data="back_to_mafia")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await query.edit_message_text(
                    f"ğŸ’€ **MISJA NIEUDANA!**\n\n"
                    f"ğŸ¯ {mission['name']}\n"
                    f"ğŸ˜µ ZostaÅ‚eÅ› przyÅ‚apany przez policjÄ™!\n"
                    f"âš ï¸ Szansa powodzenia byÅ‚a: {success_chance}%\n\n"
                    f"â° SprÃ³buj ponownie za 30 minut!",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )

        # Dodaj brakujÄ…ce handlery dla gier
        elif query.data == "game_blackjack":
            await query.edit_message_text(
                "ğŸƒ **BLACKJACK DON MLEKO**\n\n"
                "Cel: Uzyskaj 21 lub blisko 21, ale nie przekrocz!\n"
                "UÅ¼ycie: `/blackjack [stawka]`\n\n"
                "ğŸ¯ Minimalna stawka: 10 DMT\n"
                "ğŸ¯ Maksymalna stawka: 200 DMT\n\n"
                "ğŸ’¡ Wpisz komendÄ™ w chacie aby zagraÄ‡!",
                parse_mode='Markdown'
            )

        elif query.data == "game_dice":
            await query.edit_message_text(
                "ğŸ² **GRA W KOÅšCI DON MLEKO**\n\n"
                "Zgadnij sumÄ™ dwÃ³ch koÅ›ci!\n"
                "UÅ¼ycie: `/dice [stawka] [suma]`\n\n"
                "ğŸ¯ Suma: 2-12\n"
                "ğŸ¯ Stawka: 5-100 DMT\n\n"
                "ğŸ’° **WypÅ‚aty:**\n"
                "â€¢ 7 (najczÄ™stsza): x4\n"
                "â€¢ 6,8: x5 | 5,9: x6\n"
                "â€¢ 4,10: x8 | 3,11: x10\n"
                "â€¢ 2,12 (najrzadsza): x15\n\n"
                "ğŸ’¡ Wpisz komendÄ™ w chacie aby zagraÄ‡!",
                parse_mode='Markdown'
            )

        elif query.data == "game_crash":
            await query.edit_message_text(
                "ğŸš€ **CRASH GAME DON MLEKO**\n\n"
                "Rakieta leci w gÃ³rÄ™! Kiedy siÄ™ zatrzyma?\n"
                "UÅ¼ycie: `/crash [stawka] [multiplier]`\n\n"
                "ğŸ¯ Stawka: 10-200 DMT\n"
                "ğŸ¯ Multiplier: 1.1x - 10.0x\n\n"
                "ğŸ“ˆ Im wyÅ¼szy multiplier, tym wiÄ™ksze ryzyko!\n"
                "ğŸŒ™ JeÅ›li rakieta doleci do Twojego multiplikatora,\n"
                "    wygrywasz stawkÄ™ x multiplier!\n\n"
                "ğŸ’¡ Wpisz komendÄ™ w chacie aby zagraÄ‡!",
                parse_mode='Markdown'
            )

        elif query.data == "game_wheel":
            await query.edit_message_text(
                "ğŸ¡ **KOÅO FORTUNY DON MLEKO**\n\n"
                "ZakrÄ™Ä‡ koÅ‚em i zobacz co wypadnie!\n"
                "UÅ¼ycie: `/wheel [stawka]`\n\n"
                "ğŸ¯ Stawka: 20-150 DMT\n\n"
                "ğŸ **NAGRODY:**\n"
                "ğŸ’ JACKPOT (1%) - x20\n"
                "ğŸš€ DMT TO MOON (5%) - x10\n"
                "ğŸ’° DuÅ¼a wygrana (10%) - x5\n"
                "ğŸ¥› Don Mleko (15%) - x3\n"
                "ğŸ„ Krowa (25%) - x2\n"
                "ğŸ˜¢ Nic (44%) - x0\n\n"
                "ğŸ’¡ Wpisz komendÄ™ w chacie aby zagraÄ‡!",
                parse_mode='Markdown'
            )


    except Exception as e:
        logging.error(f"BÅ‚Ä…d w button_callback: {e}")

# === FUNKCJE MIASTA ===

async def city_overview(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        territory_owned = user_data.get('territory_owned', 0)
        special_buildings = user_data.get('special_buildings', [])

        city_text = "ğŸ™ï¸ **TWOJE MIASTO DON MLEKO:**\n\n"

        # PokaÅ¼ posiadane terytoria
        city_text += "ğŸ˜ï¸ **DZIELNICE:**\n"
        total_income = 0
        for i in range(territory_owned):
            territory = TERRITORIES[i]
            total_income += territory['income']
            city_text += f"âœ… {territory['name']} (+{territory['income']} DMT/h)\n"

        if territory_owned < len(TERRITORIES):
            next_territory = TERRITORIES[territory_owned]
            city_text += f"ğŸ”’ NastÄ™pna: {next_territory['name']} ({next_territory['cost']} DMT)\n"

        # PokaÅ¼ specjalne budynki
        city_text += f"\nğŸ—ï¸ **SPECJALNE BUDYNKI:** ({len(special_buildings)}/5)\n"
        if special_buildings:
            for building_id in special_buildings:
                if building_id in SPECIAL_BUILDINGS:
                    building = SPECIAL_BUILDINGS[building_id]
                    city_text += f"âœ… {building['name']}\n"
        else:
            city_text += "Brak specjalnych budynkÃ³w\n"

        city_text += f"\nğŸ’° **ÅÄ…czny dochÃ³d:** {total_income} DMT/godzina\n"
        city_text += f"ğŸ‘¥ **Populacja:** {territory_owned * 1000 + len(special_buildings) * 500}\n"
        city_text += f"ğŸ“Š **Poziom miasta:** {get_city_level(territory_owned, len(special_buildings))}\n\n"

        city_text += "**KOMENDY:**\n"
        city_text += "ğŸ˜ï¸ `/territory` - Kup dzielnice\n"
        city_text += "ğŸ—ï¸ `/buildings` - Specjalne budynki\n"
        city_text += "â›ï¸ `/mining` - Rozszerzone kopanie\n"
        city_text += "ğŸ›¡ï¸ `/protection` - Zbierz dochody"

        await update.message.reply_text(city_text, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w city_overview: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w przeglÄ…dzie miasta!")

def get_city_level(territories, special_buildings):
    total_score = territories * 2 + special_buildings * 3
    if total_score >= 30:
        return "ğŸŒ† Metropolia"
    elif total_score >= 20:
        return "ğŸ™ï¸ Wielkie Miasto"
    elif total_score >= 12:
        return "ğŸ˜ï¸ Miasto"
    elif total_score >= 6:
        return "ğŸ  Miasteczko"
    else:
        return "ğŸšï¸ Wioska"

async def super_lottery(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Super loteria z mega nagrodami"""
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº cooldown (24 godziny)
        last_lottery = user_data.get('last_lottery', 0)
        now = time.time()

        if now - last_lottery < 86400:  # 24 godziny
            remaining = int(86400 - (now - last_lottery))
            hours = remaining // 3600
            minutes = (remaining % 3600) // 60
            await update.message.reply_text(f"ğŸ« NastÄ™pna loteria za {hours}h {minutes}m!")
            return

        # Koszt uczestnictwa
        cost = 1000
        if user_data.get('points', 0) < cost:
            await update.message.reply_text(f"âŒ Potrzebujesz {cost} DMT aby graÄ‡ w super loteriÄ™!")
            return

        add_points(user_id, -cost)

        # Super nagrody
        lottery_prizes = [
            {"name": "ğŸ’¥ MEGA JACKPOT", "value": 100000, "chance": 1},
            {"name": "ğŸš€ KOSMICZNY BONUS", "value": 50000, "chance": 3},
            {"name": "ğŸ’ DIAMENTOWA NAGRODA", "value": 25000, "chance": 5},
            {"name": "ğŸ† ZÅOTY BONUS", "value": 10000, "chance": 10},
            {"name": "ğŸ¥ˆ SREBRNY BONUS", "value": 5000, "chance": 20},
            {"name": "ğŸ¥‰ BRÄ„ZOWY BONUS", "value": 2000, "chance": 30},
            {"name": "ğŸ˜¢ Niestety nic", "value": 0, "chance": 31}
        ]

        rand = random.randint(1, 100)
        cumulative = 0

        for prize in lottery_prizes:
            cumulative += prize["chance"]
            if rand <= cumulative:
                result = prize
                break

        if result["value"] > 0:
            # SprawdÅº bonusy z budynkÃ³w
            special_buildings = user_data.get('special_buildings', [])
            multiplier = 1.0

            if 'casino_royale' in special_buildings:
                multiplier += 1.0  # x2 z casino
            if 'rakieta_don_mleko' in special_buildings:
                multiplier += 1.0  # kolejne x2

            final_reward = int(result["value"] * multiplier)
            points = add_points(user_id, final_reward)

            # Auto-post dla duÅ¼ych wygranych
            if final_reward >= 25000:
                username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"
                auto_create_achievement_post(user_id, username, 'jackpot', f"{final_reward:,}")

            await update.message.reply_text(
                f"ğŸ« **SUPER LOTERIA WYNIK!**\n\n"
                f"ğŸ‰ {result['name']}\n"
                f"ğŸ’° Nagroda bazowa: {result['value']:,} DMT\n"
                f"ğŸ”¥ MnoÅ¼nik budynkÃ³w: x{multiplier}\n"
                f"ğŸ’ ÅÄ„CZNA WYGRANA: {final_reward:,} DMT!\n"
                f"ğŸ† Masz teraz: {points:,} punktÃ³w\n\n"
                f"ğŸ² Szansa byÅ‚a: {result['chance']}%"
            )
        else:
            await update.message.reply_text(
                f"ğŸ« **SUPER LOTERIA**\n\n"
                f"ğŸ˜¢ {result['name']}\n"
                f"ğŸ’¸ StraciÅ‚eÅ›: {cost} DMT\n"
                f"ğŸ€ WiÄ™cej szczÄ™Å›cia jutro!\n\n"
                f"ğŸ’¡ Zbuduj Casino Royale dla bonusÃ³w!"
            )

        user_data['last_lottery'] = now
        update_user_data(user_id, user_data)

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w super_lottery: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w super loterii!")

async def time_travel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """PodrÃ³Å¼e w czasie - skip cooldown'y"""
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº czy ma Portal Czasowy
        special_buildings = user_data.get('special_buildings', [])
        if 'portal_czasowy' not in special_buildings:
            await update.message.reply_text("âŒ Potrzebujesz Portal Czasowy aby podrÃ³Å¼owaÄ‡ w czasie!")
            return

        if not context.args:
            await update.message.reply_text(
                "ğŸŒ€ **PORTAL CZASOWY**\n\n"
                "PomiÅ„ cooldown'y za DMT!\n\n"
                "ğŸ“ UÅ¼ycie: `/timetravel [akcja]`\n\n"
                "**DOSTÄ˜PNE AKCJE:**\n"
                "â€¢ mining - PomiÅ„ cooldown kopania (500 DMT)\n"
                "â€¢ heist - PomiÅ„ cooldown napadu (1000 DMT)\n"
                "â€¢ mission - PomiÅ„ cooldown misji (750 DMT)\n"
                "â€¢ lottery - PomiÅ„ cooldown loterii (2000 DMT)\n"
                "â€¢ all - PomiÅ„ wszystkie cooldown'y (3000 DMT)"
            )
            return

        action = context.args[0].lower()
        costs = {
            'mining': 500,
            'heist': 1000,
            'mission': 750,
            'lottery': 2000,
            'all': 3000
        }

        if action not in costs:
            await update.message.reply_text("âŒ Nieznana akcja! UÅ¼yj: mining, heist, mission, lottery, all")
            return

        cost = costs[action]
        if user_data.get('points', 0) < cost:
            await update.message.reply_text(f"âŒ Potrzebujesz {cost} DMT na podrÃ³Å¼ w czasie!")
            return

        add_points(user_id, -cost)
        now = time.time()

        # Resetuj cooldown'y
        if action == 'mining' or action == 'all':
            for location in MINING_LOCATIONS.keys():
                user_data[f'last_mine_{location}'] = 0
            user_data['last_mine'] = 0

        if action == 'heist' or action == 'all':
            user_data['last_heist'] = 0

        if action == 'mission' or action == 'all':
            user_data['last_mission'] = 0

        if action == 'lottery' or action == 'all':
            user_data['last_lottery'] = 0

        user_data['last_timetravel'] = now
        update_user_data(user_id, user_data)

        await update.message.reply_text(
            f"ğŸŒ€ **PODRÃ“Å» W CZASIE UDANA!**\n\n"
            f"âš¡ Resetowano cooldown: {action}\n"
            f"ğŸ’¸ Koszt: {cost} DMT\n"
            f"ğŸ’ PozostaÅ‚o: {get_user_points(user_id)} DMT\n\n"
            f"ğŸ¯ Wszystkie akcje znÃ³w dostÄ™pne!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w time_travel: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w portalu czasowym!")

async def special_buildings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        if not context.args:
            buildings_text = "ğŸ—ï¸ **SPECJALNE BUDYNKI:**\n\n"
            owned_buildings = user_data.get('special_buildings', [])

            for building_id, building in SPECIAL_BUILDINGS.items():
                status = "âœ… POSIADANE" if building_id in owned_buildings else f"ğŸ’° {building['cost']} DMT"
                buildings_text += (
                    f"**{building['name']}**\n"
                    f"ğŸ“ {building['description']}\n"
                    f"ğŸ’° Koszt: {building['cost']} DMT\n"
                    f"ğŸ“Š Status: {status}\n\n"
                )

            buildings_text += f"ğŸ—ï¸ Posiadasz: {len(owned_buildings)}/5 budynkÃ³w\n"
            buildings_text += "UÅ¼yj: `/buildings [nazwa]` aby kupiÄ‡\n"
            buildings_text += "DostÄ™pne: mleczarnia, laboratorium, akademia, skarbiec, fabryka_botow"

            await update.message.reply_text(buildings_text, parse_mode='Markdown')
            return

        building_id = context.args[0].lower()

        if building_id not in SPECIAL_BUILDINGS:
            await update.message.reply_text("âŒ Nieznany budynek! DostÄ™pne: mleczarnia, laboratorium, akademia, skarbiec, fabryka_botow")
            return

        owned_buildings = user_data.get('special_buildings', [])

        if building_id in owned_buildings:
            await update.message.reply_text("âŒ Ten budynek juÅ¼ posiadasz!")
            return

        building = SPECIAL_BUILDINGS[building_id]
        points = user_data.get('points', 0)

        if points < building['cost']:
            await update.message.reply_text(f"âŒ Potrzebujesz {building['cost']} DMT aby kupiÄ‡ {building['name']}!")
            return

        # Kup budynek
        add_points(user_id, -building['cost'])
        owned_buildings.append(building_id)
        user_data['special_buildings'] = owned_buildings
        update_user_data(user_id, user_data)

        new_points = get_user_points(user_id)

        await update.message.reply_text(
            f"ğŸ—ï¸ **BUDYNEK WYBUDOWANY!**\n\n"
            f"ğŸ›ï¸ {building['name']}\n"
            f"ğŸ’¸ Koszt: {building['cost']} DMT\n"
            f"ğŸ¯ Bonus: {building['description']}\n"
            f"ğŸ’ PozostaÅ‚o punktÃ³w: {new_points}\n\n"
            f"ğŸ—ï¸ Posiadasz {len(owned_buildings)}/5 specjalnych budynkÃ³w!"
        )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w special_buildings: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w systemie budynkÃ³w!")

async def advanced_mining(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        if not context.args:
            mining_text = "â›ï¸ **ROZSZERZONE KOPANIE:**\n\n"
            mining_level = user_data.get('mining_level', 1)

            mining_text += f"ğŸ“Š **TwÃ³j poziom mining:** {mining_level}\n\n"

            for location_id, location in MINING_LOCATIONS.items():
                if mining_level >= location['unlock_level']:
                    status = "âœ… DOSTÄ˜PNE"
                else:
                    status = f"ğŸ”’ Wymagany poziom {location['unlock_level']}"

                mining_text += (
                    f"**{location['name']}**\n"
                    f"ğŸ“ {location['description']}\n"
                    f"ğŸ¯ Szanse: {location['success_rate']}%\n"
                    f"ğŸ’ Nagroda: {location['base_reward'][0]}-{location['base_reward'][1]} DMT\n"
                    f"â° Cooldown: {location['cooldown']//60} min\n"
                    f"ğŸŒŸ Rzadkie: {location['rare_chance']}%\n"
                    f"ğŸ“Š Status: {status}\n\n"
                )

            mining_text += "UÅ¼yj: `/mining [lokacja]` aby kopaÄ‡\n"
            mining_text += "DostÄ™pne: podstawowa, gleboka, diamentowa, magiczna, kosmiczna"

            await update.message.reply_text(mining_text, parse_mode='Markdown')
            return

        location_id = context.args[0].lower()

        # Mapowanie nazw
        location_mapping = {
            'podstawowa': 'kopalnia_podstawowa',
            'gleboka': 'kopalnia_glleboka',
            'diamentowa': 'kopalnia_diamentowa',
            'magiczna': 'kopalnia_magiczna',
            'kosmiczna': 'kopalnia_kosmiczna'
        }

        if location_id in location_mapping:
            location_id = location_mapping[location_id]

        if location_id not in MINING_LOCATIONS:
            await update.message.reply_text("âŒ Nieznana lokacja! UÅ¼yj: podstawowa, gleboka, diamentowa, magiczna, kosmiczna")
            return

        location = MINING_LOCATIONS[location_id]
        mining_level = user_data.get('mining_level', 1)

        if mining_level < location['unlock_level']:
            await update.message.reply_text(f"âŒ Wymagany poziom mining: {location['unlock_level']}! Masz: {mining_level}")
            return

        # SprawdÅº cooldown dla tej lokacji
        last_mine_key = f'last_mine_{location_id}'
        last_mine = user_data.get(last_mine_key, 0)
        now = time.time()

        if now - last_mine < location['cooldown']:
            remaining = int(location['cooldown'] - (now - last_mine))
            minutes = remaining // 60
            seconds = remaining % 60
            await update.message.reply_text(f"â° {location['name']} - Musisz poczekaÄ‡ {minutes}m {seconds}s!")
            return

        # Oblicz bonusy z budynkÃ³w
        special_buildings = user_data.get('special_buildings', [])
        mining_boost = 0
        rare_boost = 0
        all_rewards_boost = 0
        time_reduction = 0

        if 'mleczarnia' in special_buildings:
            mining_boost += 25
        if 'laboratorium' in special_buildings:
            rare_boost += 50
        if 'cyber_centrum' in special_buildings:
            all_rewards_boost += 40
        if 'rakieta_don_mleko' in special_buildings:
            mining_boost += 200  # MEGA BOOST
            rare_boost += 100
        if 'portal_czasowy' in special_buildings:
            time_reduction += 75  # Redukuje cooldown
        if 'centrum_dowodzenia' in special_buildings:
            mining_boost += 60
            rare_boost += 30

        # Kopanie!
        success_chance = min(95, location['success_rate'] + mining_boost // 5)

        if random.randint(1, 100) <= success_chance:
            # Sukces!
            base_min, base_max = location['base_reward']
            # Bonus z poziomu mining
            level_multiplier = 1 + (mining_level - location['unlock_level']) * 0.1
            # Bonus z budynkÃ³w
            building_multiplier = 1 + mining_boost / 100

            final_min = int(base_min * level_multiplier * building_multiplier)
            final_max = int(base_max * level_multiplier * building_multiplier)

            mined_dmt = random.randint(final_min, final_max)
            points = add_points(user_id, mined_dmt)

            # Szansa na rzadkie mineraÅ‚y
            rare_found = None
            enhanced_rare_chance = location['rare_chance'] + rare_boost / 10

            if random.randint(1, 1000) <= enhanced_rare_chance * 10:
                # Znaleziono rzadki mineraÅ‚!
                available_minerals = [(mineral_id, mineral) for mineral_id, mineral in RARE_MINERALS.items()
                                    if random.randint(1, 1000) <= mineral['chance'] * 10]
                if available_minerals:
                    mineral_id, rare_found = random.choice(available_minerals)
                    rare_bonus = rare_found['value']
                    points = add_points(user_id, rare_bonus)

                    # Dodaj mineraÅ‚ do inwentarza gracza
                    user_data = get_user_data_full(user_id)
                    rare_minerals = user_data.get('rare_minerals_found', {})
                    rare_minerals[mineral_id] = rare_minerals.get(mineral_id, 0) + 1
                    user_data['rare_minerals_found'] = rare_minerals
                    update_user_data(user_id, user_data)

            # Szansa na level up
            level_up_text = ""
            if random.randint(1, 20) == 1:  # 5% szansy
                user_data['mining_level'] = mining_level + 1
                level_bonus = (mining_level + 1) * 10
                points = add_points(user_id, level_bonus)
                # Pobierz zaktualizowane dane po dodaniu punktÃ³w
                user_data = get_user_data_full(user_id)
                level_up_text = f"\nğŸ‰ LEVEL UP! Mining level {mining_level + 1}!\nğŸ’ Bonus: +{level_bonus} DMT!"

            user_data[last_mine_key] = now
            update_user_data(user_id, user_data)

            result_text = (
                f"â›ï¸ **UDANE KOPANIE!**\n\n"
                f"ğŸ“ Lokacja: {location['name']}\n"
                f"ğŸ’ Wykopane DMT: {mined_dmt}\n"
                f"ğŸ“Š Szanse byÅ‚y: {success_chance}%\n"
            )

            if rare_found:
                result_text += f"\nğŸŒŸ **RZADKI MINERAÅ!**\nğŸ’  {rare_found['name']} (+{rare_found['value']} DMT)\nğŸ“ {rare_found['description']}\n"

            result_text += f"\nğŸ’° ÅÄ…cznie punktÃ³w: {points}{level_up_text}"

            await update.message.reply_text(result_text, parse_mode='Markdown')
        else:
            # PoraÅ¼ka
            user_data[last_mine_key] = now
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸ’¥ **KOPANIE NIEUDANE!**\n\n"
                f"ğŸ“ {location['name']}\n"
                f"ğŸ˜µ Nic nie znalazÅ‚eÅ› tym razem!\n"
                f"âš ï¸ Szanse byÅ‚y: {success_chance}%\n\n"
                f"â° SprÃ³buj ponownie za {location['cooldown']//60} minut!"
            )

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w advanced_mining: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w rozszerzonym kopaniu!")

# === SYSTEM BATTLE (ARENA BITEW) ===
async def battle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "battle")
        if not can_proceed:
            await update.message.reply_text(f"âŒ {message}")
            return

        # SprawdÅº cooldown (10 minut)
        last_battle = user_data.get('last_battle', 0)
        now = time.time()
        cooldown = 600  # 10 minut

        if now - last_battle < cooldown:
            remaining = int(cooldown - (now - last_battle))
            minutes = remaining // 60
            seconds = remaining % 60
            await update.message.reply_text(f"â° NastÄ™pna bitwa za {minutes}m {seconds}s!")
            return

        # Lista przeciwnikÃ³w
        enemies = [
            {"name": "ğŸ· Papierowa Åšwinia", "difficulty": 1, "reward": (5, 15), "hp": 30},
            {"name": "ğŸº Szary Wilk", "difficulty": 2, "reward": (10, 25), "hp": 50},
            {"name": "ğŸ¦… Stalowy OrzeÅ‚", "difficulty": 3, "reward": (15, 35), "hp": 70},
            {"name": "ğŸ² Czerwony Smok", "difficulty": 4, "reward": (25, 50), "hp": 100},
            {"name": "ğŸ‘‘ Boss Kraina", "difficulty": 5, "reward": (40, 80), "hp": 150},
            {"name": "ğŸ¤– Cyber Demon", "difficulty": 6, "reward": (60, 120), "hp": 200},
            {"name": "ğŸ‘» Duch Mafii", "difficulty": 7, "reward": (80, 160), "hp": 250},
            {"name": "âš¡ Zeus Mleczny", "difficulty": 8, "reward": (100, 200), "hp": 300}
        ]

        # Wybierz przeciwnika bazujÄ…c na poziomie gracza
        battle_wins = user_data.get('battle_wins', 0)
        player_level = min(battle_wins // 5 + 1, len(enemies))
        available_enemies = enemies[:player_level]
        enemy = random.choice(available_enemies)

        # Oblicz siÅ‚Ä™ gracza
        mining_level = user_data.get('mining_level', 1)
        mafia_respect = user_data.get('mafia_respect', 0)
        player_power = 50 + mining_level * 10 + mafia_respect // 10

        # Bonusy z budynkÃ³w
        special_buildings = user_data.get('special_buildings', [])
        if 'akademia' in special_buildings:
            player_power += 30
        if 'centrum_dowodzenia' in special_buildings:
            player_power += 50

        # Symulacja bitwy
        player_hp = 100
        enemy_hp = enemy["hp"]
        battle_log = f"âš”ï¸ **ARENA BITEW DON MLEKO**\n\nğŸ‘¤ {update.effective_user.first_name or 'Wojownik'} vs {enemy['name']}\n\n"

        round_num = 1
        while player_hp > 0 and enemy_hp > 0 and round_num <= 10:
            # Atak gracza
            player_damage = random.randint(player_power//3, player_power//2)
            enemy_hp = max(0, enemy_hp - player_damage)
            battle_log += f"ğŸ—¡ï¸ Runda {round_num}: ZadaÅ‚eÅ› {player_damage} obraÅ¼eÅ„! (Przeciwnik: {enemy_hp}HP)\n"

            if enemy_hp <= 0:
                break

            # Atak przeciwnika
            enemy_damage = random.randint(enemy["difficulty"] * 5, enemy["difficulty"] * 15)
            player_hp = max(0, player_hp - enemy_damage)
            battle_log += f"ğŸ’¥ {enemy['name']} zadaÅ‚ {enemy_damage} obraÅ¼eÅ„! (Ty: {player_hp}HP)\n\n"

            round_num += 1

        # Wynik bitwy
        if player_hp > 0:
            # Wygrana!
            reward = random.randint(*enemy["reward"])
            points, success = add_points_with_limit(user_id, reward)

            user_data['battle_wins'] = user_data.get('battle_wins', 0) + 1
            user_data['last_battle'] = now
            update_user_data(user_id, user_data)

            # SprawdÅº odznaki
            if user_data['battle_wins'] >= 10:
                check_and_award_badge(user_id, "battle_champion")

            battle_log += f"ğŸ‰ **ZWYCIÄ˜STWO!**\nğŸ’° Nagroda: +{reward} DMT\nğŸ’ ÅÄ…cznie punktÃ³w: {points}\nğŸ† Wygrane bitwy: {user_data['battle_wins']}"

            if not success:
                battle_log += "\nâš ï¸ OsiÄ…gniÄ™to limit punktÃ³w za godzinÄ™!"

        else:
            # Przegrana
            user_data['last_battle'] = now
            update_user_data(user_id, user_data)

            battle_log += f"ğŸ’€ **PRZEGRANA!**\nğŸ˜µ ZostaÅ‚eÅ› pokonany przez {enemy['name']}!\nğŸ’ª Trenuj wiÄ™cej i sprÃ³buj ponownie!"

        await update.message.reply_text(battle_log, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w battle: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w arenie bitew!")

# Mining System (stary - zachowaj dla kompatybilnoÅ›ci)
async def mine(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # SprawdÅº cooldown (5 minut)
        last_mine = user_data.get('last_mine', 0)
        now = time.time()
        cooldown = 300  # 5 minut

        if now - last_mine < cooldown:
            remaining = int(cooldown - (now - last_mine))
            minutes = remaining // 60
            seconds = remaining % 60
            await update.message.reply_text(f"â° Musisz poczekaÄ‡ {minutes}m {seconds}s przed kolejnym kopaniem!")
            return

        mining_level = user_data.get('mining_level', 1)

        # SprawdÅº super rzadkÄ… szansÄ™ na DMTB (1:1000000)
        dmtb_chance = random.randint(1, 1000000)

        if dmtb_chance == 777777:  # Ultra rzadka szansa!
            # MEGA JACKPOT - DMTB!
            mega_reward = 1000000
            points = add_points(user_id, mega_reward)

            # Pobierz zaktualizowane dane po dodaniu punktÃ³w
            user_data = get_user_data_full(user_id)
            user_data['mining_level'] = min(mining_level + 5, 99)
            user_data['last_mine'] = now

            # Specjalna odznaka
            if check_and_award_badge(user_id, "dmtb_finder"):
                BADGES["dmtb_finder"] = {"name": "ğŸŒŸ DMTB Finder", "desc": "WykopaÅ‚ legendarny DMTB!"}

            update_user_data(user_id, user_data)

            # Auto-post o MEGA jackpot
            username = update.effective_user.first_name or f"Gracz{str(user_id)[-4:]}"
            auto_create_achievement_post(user_id, username, 'jackpot', f"{mega_reward:,}")

            await update.message.reply_text(
                f"ğŸŒŸğŸŒŸğŸŒŸ MEGA JACKPOT! ğŸŒŸğŸŒŸğŸŒŸ\n\n"
                f"ğŸ’« WYKOPAÅEÅš LEGENDARNY DMTB!\n"
                f"ğŸ† NAGRODA: {mega_reward:,} punktÃ³w!\n"
                f"âš¡ Mining level +5!\n"
                f"ğŸ–ï¸ Specjalna odznaka: DMTB Finder!\n\n"
                f"ğŸ’ ÅÄ…cznie punktÃ³w: {points:,}\n"
                f"ğŸ“ˆ Szansa byÅ‚a 1:1,000,000!\n\n"
                f"ğŸ„ Don Mleko jest dumny!"
            )
            return

        # ZwykÅ‚e kopanie
        success_chance = min(80, 30 + mining_level * 5)

        if random.randint(1, 100) <= success_chance:
            # Sukces!
            mining_level = user_data.get('mining_level', 1) # Ensure mining_level is up to date
            base_min, base_max = random.randint(mining_level, mining_level * 3) # Simplified reward calculation for old mine
            mined_dmt = random.randint(base_min, base_max)
            points = add_points(user_id, mined_dmt)

            # Szansa na level up (10%)
            if random.randint(1, 10) == 1:
                level_bonus = mining_level * 5
                points = add_points(user_id, level_bonus)  # Zaktualizuj points
                # Pobierz zaktualizowane dane po dodaniu punktÃ³w
                user_data = get_user_data_full(user_id)
                user_data['mining_level'] = mining_level + 1
                level_text = f"\nğŸ‰ LEVEL UP! Mining level {mining_level + 1}!\nğŸ’ Bonus: +{level_bonus} punktÃ³w!"

            else:
                level_text = ""

            user_data['last_mine'] = now
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"â›ï¸ SUKCES!\n\n"
                f"ğŸ’ WykopaÅ‚eÅ›: {mined_dmt} DMT!\n"
                f"ğŸ“Š Mining level: {mining_level}\n"
                f"ğŸ’° ÅÄ…cznie punktÃ³w: {points}{level_text}\n\n"
                f"ğŸŒŸ Szansa na DMTB: 1:1,000,000\n"
                f"â° Kolejne kopanie za 5 minut!"
            )
        else:
            # PoraÅ¼ka
            user_data['last_mine'] = now
            update_user_data(user_id, user_data)

            await update.message.reply_text(
                f"ğŸ’¥ Nic nie wykopaÅ‚eÅ›!\n\n"
                f"â›ï¸ SprÃ³buj ponownie za 5 minut!\n"
                f"ğŸ’¡ WyÅ¼szy mining level = wiÄ™ksze szanse!"
            )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w mine: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w kopalni!")

# Slot Machine (bez zmian)
async def slots(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)

        # Koszt gry
        cost = 5
        if user_data.get('points', 0) < cost:
            await update.message.reply_text(f"âŒ Potrzebujesz {cost} punktÃ³w aby zagraÄ‡ w slots!")
            return

        # Zabierz punkty
        add_points(user_id, -cost)

        # Symbole
        symbols = ["ğŸ„", "ğŸ’", "ğŸ¥›", "ğŸš€", "ğŸŒ™", "â­"]

        # Losuj 3 symbole
        result = [random.choice(symbols) for _ in range(3)]

        # SprawdÅº wygranÄ…
        if result[0] == result[1] == result[2]:
            if result[0] == "ğŸ„":
                win = 100
            elif result[0] == "ğŸ’":
                win = 50
            elif result[0] == "ğŸš€":
                win = 30
            else:
                win = 20

            final_points = add_points(user_id, win)
            message = f"ğŸ‰ JACKPOT! {' '.join(result)}\nğŸ’° WygraÅ‚eÅ›: {win} punktÃ³w!"
        elif result[0] == result[1] or result[1] == result[2] or result[0] == result[2]:
            win = 10
            final_points = add_points(user_id, win)
            message = f"ğŸŠ Para! {' '.join(result)}\nğŸ’° WygraÅ‚eÅ›: {win} punktÃ³w!"
        else:
            win = 0
            final_points = get_user_points(user_id)  # Pobierz aktualne punkty
            message = f"ğŸ’€ Przegrana! {' '.join(result)}\nğŸ˜¢ SprÃ³buj ponownie!"

        await update.message.reply_text(
            f"ğŸ° SLOTS DON MLEKO ğŸ°\n\n"
            f"{message}\n\n"
            f"ğŸ’ Twoje punkty: {final_points}\n"
            f"ğŸ’¸ Koszt gry: {cost} punktÃ³w"
        )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w slots: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w automacie!")

# Ruleta (bez zmian)
async def roulette(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        if not context.args or len(context.args) != 2:
            await update.message.reply_text(
                "ğŸ¯ RULETA DON MLEKO!\n\n"
                "UÅ¼ycie: /roulette [stawka] [kolor]\n\n"
                "Kolory:\n"
                "ğŸ”´ red - x2 (47% szans)\n"
                "âš« black - x2 (47% szans)\n"
                "ğŸŸ¢ green - x14 (6% szans)\n\n"
                "PrzykÅ‚ad: /roulette 10 red"
            )
            return

        try:
            bet = int(context.args[0])
            color = context.args[1].lower()
        except ValueError:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ liczbÄ…!")
            return

        if color not in ['red', 'black', 'green']:
            await update.message.reply_text("âŒ DostÄ™pne kolory: red, black, green")
            return

        user_data = get_user_data_full(user_id)
        if user_data.get('points', 0) < bet:
            await update.message.reply_text("âŒ Nie masz wystarczajÄ…co punktÃ³w!")
            return

        if bet < 1 or bet > 100:
            await update.message.reply_text("âŒ Stawka musi byÄ‡ miÄ™dzy 1 a 100 punktÃ³w!")
            return

        # Zabierz stawkÄ™
        add_points(user_id, -bet)

        # Losuj wynik
        roulette_number = random.randint(0, 36)

        if roulette_number == 0:
            winning_color = "green"
            color_emoji = "ğŸŸ¢"
        elif roulette_number % 2 == 1:
            winning_color = "red"
            color_emoji = "ğŸ”´"
        else:
            winning_color = "black"
            color_emoji = "âš«"

        # SprawdÅº wygranÄ…
        if color == winning_color:
            if color == "green":
                winnings = bet * 14
            else:
                winnings = bet * 2

            final_points = add_points(user_id, winnings)

            await update.message.reply_text(
                f"ğŸ‰ WYGRANA!\n\n"
                f"ğŸ¯ WypadÅ‚o: {roulette_number} {color_emoji}\n"
                f"ğŸ’° WygraÅ‚eÅ›: {winnings} punktÃ³w!\n"
                f"ğŸ’ Masz teraz: {final_points} punktÃ³w"
            )
        else:
            current_points = get_user_points(user_id)  # Pobierz aktualne punkty
            await update.message.reply_text(
                f"ğŸ’€ PRZEGRANA!\n\n"
                f"ğŸ¯ WypadÅ‚o: {roulette_number} {color_emoji}\n"
                f"ğŸ’¸ StraciÅ‚eÅ›: {bet} punktÃ³w\n"
                f"ğŸ’ Masz teraz: {current_points} punktÃ³w"
            )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w roulette: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w rulecie!")

# --- Pobieranie kursu (RZECZYWISTY KURS DMT) ---
async def get_price():
    """Pobiera kurs DMT z fallback na symulowany kurs"""
    try:
        # Najpierw sprÃ³buj z prawdziwym API (poprawiony URL)
        timeout = aiohttp.ClientTimeout(total=8, connect=3, sock_read=5)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            # Poprawiony URL API
            url = "https://api.dexscreener.io/latest/dex/pairs/bsc/0x067DEAB2f36aD3c1e267849a1672C1735A788ccf"

            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    if data and "pair" in data and data["pair"]:
                        pair_data = data["pair"]

                        price_usd = pair_data.get("priceUsd", "0")
                        price_change_24h = pair_data.get("priceChange", {}).get("h24", 0)

                        # Bezpieczne formatowanie
                        try:
                            price_float = float(price_usd)
                            if price_float < 0.000001:
                                formatted_price = f"{price_float:.10f}"
                            elif price_float < 0.001:
                                formatted_price = f"{price_float:.8f}"
                            else:
                                formatted_price = f"{price_float:.6f}"
                        except:
                            formatted_price = "0.000001"

                        # Trend emoji
                        try:
                            change_val = float(price_change_24h)
                            if change_val > 0:
                                trend_emoji = "ğŸ“ˆ"
                                change_text = f"+{change_val:.2f}%"
                            elif change_val < 0:
                                trend_emoji = "ğŸ“‰"
                                change_text = f"{change_val:.2f}%"
                            else:
                                trend_emoji = "â¡ï¸"
                                change_text = "0%"
                        except:
                            trend_emoji = "ğŸ“Š"
                            change_text = "N/A"

                        return (
                            f"ğŸ’ **DON MLEKO TOKEN (DMT)**\n\n"
                            f"ğŸ’° **Cena:** ${formatted_price}\n"
                            f"{trend_emoji} **24h:** {change_text}\n"
                            f"ğŸ”— **BSC:** 0x067DEAB2f36aD3c1e267849a1672C1735A788ccf\n"
                            f"ğŸ“ˆ **DexScreener:** [Zobacz wykres](https://dexscreener.com/bsc/0x067DEAB2f36aD3c1e267849a1672C1735A788ccf)\n\n"
                            f"ğŸ„ **Don Mleko zawsze na szczycie!**"
                        )

    except Exception as e:
        logging.warning(f"API error (kontynuujÄ™ z fallback): {e}")

    # Zawsze dziaÅ‚ajÄ…cy fallback z symulowanym kursem
    mock_price = f"0.0000{random.randint(100, 999)}"
    trend_options = ["ğŸ“ˆ +5.2%", "ğŸ“‰ -2.1%", "â¡ï¸ 0%", "ğŸ“ˆ +12.8%", "ğŸ“‰ -7.3%"]
    trend = random.choice(trend_options)

    return (
        f"ğŸ“Š **DON MLEKO TOKEN (DMT)**\n\n"
        f"ğŸ’° **Cena:** ${mock_price}\n"
        f"{trend}\n"
        f"ğŸ”— **BSC:** 0x067DEAB2f36aD3c1e267849a1672C1735A788ccf\n"
        f"ğŸ“ˆ **DexScreener:** [Zobacz wykres](https://dexscreener.com/bsc/0x067DEAB2f36aD3c1e267849a1672C1735A788ccf)\n\n"
        f"ğŸ’¡ **Demo Mode** - prawdziwy kurs wkrÃ³tce!\n"
        f"ğŸ„ **Don Mleko zawsze na szczycie!**"
    )

def check_and_award_badge(user_id, badge_type):
    try:
        user_data = get_user_data_full(user_id)
        badges = user_data.get('badges', [])

        if badge_type not in badges:
            badges.append(badge_type)
            user_data['badges'] = badges
            update_user_data(user_id, user_data)
            return True
        return False
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w check_and_award_badge: {e}")
        return False

def get_user_rank(points):
    if points >= 500:
        return "ğŸ‘‘ Legenda rodziny"
    elif points >= 100:
        return "ğŸ’ Diamond Hands"
    elif points >= 50:
        return "ğŸ¥‡ Don Mleko VIP"
    elif points >= 25:
        return "ğŸ¥ˆ Kapitan rodziny"
    elif points >= 10:
        return "ğŸ¥‰ Zaufany czÅ‚onek"
    else:
        return "ğŸ„ Nowy w rodzinie"

# --- Podstawowe komendy ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "start")
        if not can_proceed:
            await update.message.reply_text(f"âŒ {message}")
            return

        keyboard = [
            [InlineKeyboardButton("ğŸŒ Oficjalna Strona + Gry", url="https://donmlekotoken.netlify.app")],
            [InlineKeyboardButton("ğŸ”— Linktree", url="https://linktr.ee/donmlekotoken")],
            [InlineKeyboardButton("ğŸ¥ TikTok", url="https://www.tiktok.com/@donmlekotoken0")],
            [InlineKeyboardButton("ğŸ’ DexScreener", url="https://dexscreener.com/bsc/0x1fAc48db5079567D8769c9f1c16b228DB435C018")],
            [InlineKeyboardButton("ğŸ“± Telegram", url="https://t.me/donmlekotoken")],
            [InlineKeyboardButton("ğŸ¦ Twitter", url="https://twitter.com/donmlekotoken")],
            [InlineKeyboardButton("ğŸ“¸ Instagram", url="https://instagram.com/donmlekotoken")],
            [InlineKeyboardButton("ğŸ’¬ Discord", url="https://discord.gg/donmleko")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        points, success = add_points_with_limit(user_id, 1)

        # SprawdÅº czy uÅ¼ytkownik ma juÅ¼ odznakÄ™ newbie
        user_data = get_user_data_full(user_id)
        if "newbie" not in user_data.get('badges', []):
            if check_and_award_badge(user_id, "newbie"):
                badge_text = f"\nğŸ‰ ZdobyÅ‚eÅ› odznakÄ™: {BADGES['newbie']['name']}!"
            else:
                badge_text = ""
        else:
            badge_text = ""

        # Dodaj losowy emotikon Don Mleko
        don_mleko_moods = ["ğŸ„ğŸ˜", "ğŸ„ğŸ’ª", "ğŸ„ğŸš€", "ğŸ„ğŸ‘‘", "ğŸ„ğŸ’"]
        mood = random.choice(don_mleko_moods)

        # Losowa motywacyjna wiadomoÅ›Ä‡
        motivational = [
            "Rodzina zawsze patrzy! ğŸ‘€ğŸ’£",
            "Diamond Hands to podstawa! ğŸ’âœ‹",
            "Do ksiÄ™Å¼yca i dalej! ğŸš€ğŸŒ™",
            "HODL jak prawdziwy wojownik! âš”ï¸",
            "Moc jest z tobÄ…! ğŸ”¥ğŸ’ª"
        ]
        motivation = random.choice(motivational)

        points_text = f"ğŸ’ Twoje punkty: {points}"
        if not success:
            points_text += " âš ï¸ (limit osiÄ…gniÄ™ty)"

        text = (
            f"{mood} Don Mleko mÃ³wi:\n"
            f"{motivation}\n\n"
            f"{points_text}{badge_text}\n\n"
            f"ğŸ“Š PODSTAWOWE KOMENDY:\n"
            f"ğŸ  /start - Menu gÅ‚Ã³wne (+1 pkt)\n"
            f"ğŸ“Š /kurs - Aktualny kurs DMT (+2 pkt)\n"
            f"ğŸ˜‚ /mem - Losowy mem/GIF (+1 pkt)\n"
            f"â“ /help - PeÅ‚na lista komend\n\n"
            f"ğŸ® KLASYCZNE GIER:\n"
            f"âš”ï¸ /battle - Arena bitew (PvE)\n"
            f"â›ï¸ /mine - Kopalnia DMT (co 5min)\n"
            f"ğŸ° /slots - Automat (koszt 5 pkt)\n"
            f"ğŸ¯ /roulette [stawka] [kolor] - Ruleta\n\n"
            f"ğŸ¤µ SYSTEM MAFII:\n"
            f"ğŸ‘¥ /mafia - Menu gÅ‚Ã³wne mafii\n"
            f"ğŸ¯ /missions [numer] - Wykonaj misjÄ™\n"
            f"ğŸ’° /heist - Napad na bank\n"
            f"ğŸ° /territory [numer] - Kup terytorium\n"
            f"ğŸ›¡ï¸ /protection - Zbierz haracze\n\n"
            f"ğŸ›ï¸ SYSTEM GILDII:\n"
            f"ğŸ‘¥ /guild - Menu gÅ‚Ã³wne gildii\n"
            f"ğŸ†• /guild create [nazwa] - UtwÃ³rz gildiÄ™ (1000 DMT)\n"
            f"ğŸ” /guild list - Zobacz dostÄ™pne gildie\n"
            f"ğŸ¤ /guild join [id] - DoÅ‚Ä…cz do gildii\n"
            f"ğŸ¯ /guild mission [nr] - Misje grupowe\n\n"
            f"ğŸ² NOWE MINI GIRY:\n"
            f"ğŸƒ /blackjack [stawka] - Karciana gra 21\n"
            f"ğŸ² /dice [stawka] [suma] - Gra w koÅ›ci\n"
            f"ğŸš€ /crash [stawka] [multiplier] - Crash Game\n"
            f"ğŸ¡ /wheel [stawka] - KoÅ‚o fortuny\n\n"
            f"ğŸ“Š STATYSTYKI:\n"
            f"ğŸ’ /punkty - Twoje punkty i ranga\n"
            f"ğŸ“ˆ /stats - SzczegÃ³Å‚owe statystyki\n"
            f"ğŸ† /ranking - TOP 15 rodziny\n\n"
            f"ğŸŒ SprawdÅº rÃ³wnieÅ¼ gry na stronie!\n"
            f"ğŸ„ Don Mleko rzÄ…dzi rodzinÄ…!"
        )

        await update.message.reply_text(text, reply_markup=reply_markup)
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w start: {e}")
        await update.message.reply_text("ğŸ„ Witaj w rodzinie Don Mleko!")

async def kurs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "kurs")
        if not can_proceed:
            await update.message.replytext(f"âŒ {message}")
            return

        points, success = add_points_with_limit(user_id, 2)
        message = await get_price()

        if success:
            await update.message.reply_text(f"{message}\nğŸ’ +2 punkty! Masz teraz: {points}")
        else:
            await update.message.reply_text(f"{message}\nâš ï¸ Limit punktÃ³w osiÄ…gniÄ™ty! Masz: {points}")
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w kurs: {e}")
        await update.message.reply_text("âŒ Chwilowy problem z kursem!")

async def mem(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "mem")
        if not can_proceed:
            await update.message.reply_text(f"âŒ {message}")
            return

        points, success = add_points_with_limit(user_id, 1)

        if random.choice([True, False]):
            mem_text = random.choice(MEMY)
            if success:
                await update.message.reply_text(f"{mem_text}\n\nğŸ’ +1 punkt! Masz: {points}")
            else:
                await update.message.reply_text(f"{mem_text}\n\nâš ï¸ Limit punktÃ³w osiÄ…gniÄ™ty! Masz: {points}")
        else:
            gif_url = random.choice(GIFY)
            try:
                caption = f"ğŸ„ Don Mleko GIF!\nğŸ’ +1 punkt! Masz teraz: {points}" if success else f"ğŸ„ Don Mleko GIF!\nâš ï¸ Limit punktÃ³w osiÄ…gniÄ™ty! Masz: {points}"
                await update.message.reply_animation(
                    animation=gif_url,
                    caption=caption
                )
            except:
                mem_text = random.choice(MEMY)
                if success:
                    await update.message.reply_text(f"{mem_text}\n\nğŸ’ +1 punkt! Masz teraz: {points}")
                else:
                    await update.message.reply_text(f"{mem_text}\n\nâš ï¸ Limit punktÃ³w osiÄ…gniÄ™ty! Masz: {points}")
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w mem: {e}")
        await update.message.reply_text("ğŸ„ Don Mleko ma problem z memami!")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)
        points = user_data.get('points', 0)

        # Personalizowane powitanie bazujÄ…ce na punktach
        if points >= 500:
            greeting = "ğŸ‘‘ Legendo rodziny!"
        elif points >= 100:
            greeting = "ğŸ’ Diamond Hand!"
        elif points >= 50:
            greeting = "ğŸ¥‡ VIP czÅ‚onku!"
        else:
            greeting = "ğŸ„ CzÅ‚onku rodziny!"

        await update.message.reply_text(
            f"{greeting} Don Mleko Bot - MEGA PRZEWODNIK:\n\n"
            f"ğŸ“ˆ PODSTAWOWE KOMENDY:\n"
            f"ğŸ  /start - Menu gÅ‚Ã³wne (+1 pkt)\n"
            f"ğŸ“Š /kurs - Aktualny kurs DMT (+2 pkt)\n"
            f"ğŸ˜‚ /mem - Losowy mem/GIF (+1 pkt)\n\n"
            f"ğŸ® KLASYCZNE GIER:\n"
            f"âš”ï¸ /battle - Arena bitew (PvE)\n"
            f"â›ï¸ /mine - Kopalnia DMT (co 5min)\n"
            f"ğŸ° /slots - Automat (koszt 5 pkt)\n"
            f"ğŸ¯ /roulette [stawka] [kolor] - Ruleta\n\n"
            f"ğŸ¤µ SYSTEM MAFII:\n"
            f"ğŸ‘¥ /mafia - Menu gÅ‚Ã³wne mafii\n"
            f"ğŸ¯ /missions [numer] - Wykonaj misjÄ™ (cooldown 30min)\n"
            f"ğŸ’° /heist - Napad na bank (cooldown 1h)\n"
            f"ğŸ° /territory [numer] - Kup terytorium (pasywny dochÃ³d)\n"
            f"ğŸ›¡ï¸ /protection - Zbierz haracze\n\n"
            f"ğŸ² NOWE MINI GIRY:\n"
            f"ğŸƒ /blackjack [stawka] - Karciana gra 21\n"
            f"ğŸ² /dice [stawka] [suma] - Gra w koÅ›ci\n"
            f"ğŸš€ /crash [stawka] [multiplier] - Crash Game\n"
            f"ğŸ¡ /wheel [stawka] - KoÅ‚o fortuny\n\n"
            f"ğŸ“Š STATYSTYKI & RANKING:\n"
            f"ğŸ’ /punkty - Twoje punkty i ranga\n"
            f"ğŸ“ˆ /stats - SzczegÃ³Å‚owe statystyki\n"
            f"ğŸ† /ranking - TOP 15 rodziny\n"
            f"ğŸ¤– /botstats - Statystyki caÅ‚ego bota\n\n"
            f"ğŸ“± SYSTEM SPOÅECZNOÅšCIOWY:\n"
            f"ğŸ“° /feed - Najnowsze posty rodziny\n"
            f"ğŸ“ /post [typ] [tytuÅ‚] [treÅ›Ä‡] - Napisz post\n"
            f"ğŸ“– /read [id] - Czytaj peÅ‚ny post\n"
            f"ğŸ‘ /like [id] - Polub post\n"
            f"ğŸ’¬ /comment [id] [treÅ›Ä‡] - Skomentuj (lub /c)\n"
            f"ğŸ“‹ /myposts - Twoje posty\n\n"
            f"ğŸŒŸ SUPER FUNKCJE:\n"
            f"ğŸ« /lottery - Super loteria (raz dziennie)\n"
            f"ğŸŒ€ /timetravel - Portal czasowy (pomiÅ„ cooldown'y)\n"
            f"ğŸš€ /megaboost - Aktywuj mega bonusy\n"
            f"ğŸ’« /godmode - Tryb boga (dla legend)\n\n"
            f"ğŸ¯ NOWE CELE:\n"
            f"â€¢ ğŸ¤µ ZostaÅ„ Donem mafii (1000+ szacunek)\n"
            f"â€¢ ğŸ° Kup terytorium i zbieraj haracze\n"
            f"â€¢ ğŸ° Wygraj w kaÅ¼dej grze hazardowej\n"
            f"â€¢ ğŸ”« Wykonaj 5 kontraktÃ³w mafijnych\n\n"
            f"ğŸŒ SprawdÅº rÃ³wnieÅ¼ gry na stronie!\n"
            f"ğŸ„ Don Mleko teraz rzÄ…dzi miastem!"
        )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w help: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w pomocy!")

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to monitor suspicious activity"""
    try:
        user_id = update.effective_user.id

        # Lista adminÃ³w (dodaj swoje ID)
        ADMIN_IDS = [123456789, 987654321]  # ZastÄ…p prawdziwymi ID adminÃ³w

        if user_id not in ADMIN_IDS:
            await update.message.reply_text("âŒ Brak uprawnieÅ„ administratora!")
            return

        data = load_user_data()
        suspicious_users = []

        now = time.time()

        for uid,user_data in data.items():
            tracking = user_data.get('activity_tracking', {})

            # SprawdÅº podejrzanÄ… aktywnoÅ›Ä‡
            commands_per_min = tracking.get('commands_count', 0)
            points_per_hour = tracking.get('points_earned_hour', 0)
            intervals = tracking.get('command_intervals', [])

            is_suspicious = False
            reasons = []

            if commands_per_min > 15:
                is_suspicious = True
                reasons.append(f"ğŸš¨ {commands_per_min} komend/min")

            if points_per_hour > 150:
                is_suspicious = True
                reasons.append(f"ğŸ’ {points_per_hour} pkt/h")

            if intervals and len(intervals) >= 3:
                avg_interval = sum(intervals) / len(intervals)
                if avg_interval < 3:
                    is_suspicious = True
                    reasons.append(f"âš¡ Avg {avg_interval:.1f}s/cmd")

            if is_suspicious:
                try:
                    chat_member = await update.get_bot().get_chat(uid)
                    username = chat_member.first_name or f"User{uid[-4:]}"
                except:
                    username = f"User{uid[-4:]}"

                suspicious_users.append({
                    'id': uid,
                    'name': username,
                    'reasons': reasons,
                    'points': user_data.get('points', 0)
                })

        if suspicious_users:
            report = "ğŸš¨ **RAPORT PODEJRZANEJ AKTYWNOÅšCI:**\n\n"
            for user in suspicious_users[:10]:  # Top 10
                report += f"ğŸ‘¤ {user['name']} (ID: {user['id'][-4:]})\n"
                report += f"ğŸ’ Punkty: {user['points']}\n"
                report += f"âš ï¸ Powody: {', '.join(user['reasons'])}\n\n"
        else:
            report = "âœ… **Brak podejrzanej aktywnoÅ›ci!**\n\nWszyscy uÅ¼ytkownicy dziaÅ‚ajÄ… normalnie."

        await update.message.reply_text(report, parse_mode='Markdown')

    except Exception as e:
        logging.error(f"BÅ‚Ä…d w admin_stats: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w raporcie administratora!")

async def punkty(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        points = get_user_points(user_id)
        username = update.effective_user.first_name or "CzÅ‚onek rodziny"
        rank = get_user_rank(points)

        # Losowe motywacyjne wiadomoÅ›ci bazujÄ…ce na punktach
        if points >= 500:
            motivation = random.choice([
                "JesteÅ› legendÄ…! ğŸ‘‘âœ¨",
                "Don Mleko jest dumny! ğŸ„ğŸ’ª",
                "KrÃ³l/KrÃ³lowa rodziny! ğŸ‘‘ğŸ†"
            ])
        elif points >= 100:
            motivation = random.choice([
                "Diamond Hands w akcji! ğŸ’ğŸ”¥",
                "Prawdziwy HODLer! ğŸš€ğŸ’ª",
                "Rodzina liczy na Ciebie! ğŸ„ğŸ’"
            ])
        elif points >= 50:
            motivation = random.choice([
                "Åšwietnie Ci idzie! ğŸ”¥â­",
                "Na dobrej drodze! ğŸš€ğŸ’«",
                "Don Mleko CiÄ™ docenia! ğŸ„ğŸ‘"
            ])
        else:
            motivation = random.choice([
                "Dopiero zaczynasz! ğŸ’ªğŸŒŸ",
                "KaÅ¼dy punkt siÄ™ liczy! ğŸ’âœ¨",
                "Trening czyni mistrza! ğŸ†âš¡"
            ])

        # Dodaj progress bar
        progress_bars = {
            500: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%",
            100: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 80%",
            50: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 50%",
            25: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 25%",
            10: "â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 10%",
            0: "â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0%"
        }

        progress = "â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0%"
        for threshold, bar in progress_bars.items():
            if points >= threshold:
                progress = bar
                break

        await update.message.reply_text(
            f"ğŸ’ **{username}** - Raport stanu!\n\n"
            f"ğŸ† **Punkty:** {points} DMT\n"
            f"ğŸ‘‘ **Ranga:** {rank}\n"
            f"ğŸ“Š **Progress:** {progress}\n\n"
            f"ğŸ’« {motivation}\n\n"
            f"ğŸ¯ **NastÄ™pny cel:**\n"
            f"{'ğŸ‘‘ JesteÅ› juÅ¼ legendÄ…!' if points >= 500 else f'â€¢ {500 - points} pkt do Legendy ğŸ‘‘' if points >= 100 else f'â€¢ {100 - points} pkt do Diamond Hands ğŸ’' if points >= 50 else f'â€¢ {50 - points} pkt do VIP ğŸ¥‡'}"
        )
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w punkty: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d przy pobieraniu punktÃ³w!")

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id
        user_data = get_user_data_full(user_id)
        username = update.effective_user.first_name or "CzÅ‚onek rodziny"

        points = user_data.get('points', 0)
        badges = user_data.get('badges', [])
        battle_wins = user_data.get('battle_wins', 0)
        mining_level = user_data.get('mining_level', 1)

        # Statystyki mafii
        mafia_respect = user_data.get('mafia_respect', 0)
        mafia_rank = get_mafia_rank(mafia_respect)
        contracts = user_data.get('contracts_completed', 0)

        # Statystyki gier
        blackjack_wins = user_data.get('blackjack_wins', 0)
        dice_wins = user_data.get('dice_wins', 0)

        rank = get_user_rank(points)

        if badges:
            badges_text = "\nğŸ… Odznaki:\n"
            for badge in badges:
                if badge in BADGES:
                    badges_text += f"â€¢ {BADGES[badge]['name']}\n"
        else:
            badges_text = "\nğŸ… Brak odznak"

        stats_text = (
            f"ğŸ“Š **Statystyki {username}:**\n\n"
            f"ğŸ’ Punkty: {points}\n"
            f"ğŸ† Ranga: {rank}\n"
            f"âš”ï¸ Wygrane bitwy: {battle_wins}\n"
            f"â›ï¸ Mining level: {mining_level}\n\n"
            f"ğŸ¤µ **MAFIA:**\n"
            f"ğŸ‘¤ Ranga: {mafia_rank}\n"
            f"â­ Szacunek: {mafia_respect}\n"
            f"ğŸ¯ Kontrakty: {contracts}\n\n"
            f"ğŸ² **GIER:**\n"
            f"ğŸƒ Blackjack: {blackjack_wins} wygranych\n"
            f"ğŸ² KoÅ›ci: {dice_wins} wygranych\n"
            f"{badges_text}"
        )

        await update.message.reply_text(stats_text, parse_mode='Markdown')
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w stats: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d przy statystykach!")

async def ranking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        data = load_user_data()
        if not data:
            await update.message.reply_text("ğŸ„ Ranking jest pusty! BÄ…dÅº pierwszy!")
            return

        # Pobierz informacje o uÅ¼ytkownikach wraz z ich danymi
        users_with_info = []
        for user_id, user_data in data.items():
            # Zawsze dodaj uÅ¼ytkownika do listy, niezaleÅ¼nie od bÅ‚Ä™dÃ³w API
            try:
                # PrÃ³buj pobraÄ‡ info o uÅ¼ytkowniku z Telegram API
                chat_member = await update.get_bot().get_chat(user_id)
                username = chat_member.first_name or f"Gracz {user_id[-4:]}"
            except:
                # JeÅ›li nie moÅ¼na pobraÄ‡, uÅ¼yj czytelnÄ… nazwÄ™
                username = f"Gracz {user_id[-4:]}"

            # Dodaj tylko uÅ¼ytkownikÃ³w ktÃ³rzy majÄ… punkty (aktywni)
            if user_data.get('points', 0) > 0:
                users_with_info.append((user_id, user_data, username))

        # Sortuj wedÅ‚ug punktÃ³w
        sorted_users = sorted(users_with_info, key=lambda x: x[1]['points'], reverse=True)[:15]

        ranking_text = "ğŸ† **TOP 15 RODZINY DON MLEKO:**\n\n"

        # Dodaj emoji dla rÃ³Å¼nych pozycji
        position_emojis = {
            1: "ğŸ¥‡", 2: "ğŸ¥ˆ", 3: "ğŸ¥‰", 4: "ğŸ…", 5: "ğŸ…",
            6: "â­", 7: "â­", 8: "â­", 9: "ğŸ’«", 10: "ğŸ’«"
        }

        for i, (user_id, user_data, username) in enumerate(sorted_users, 1):
            points = user_data['points']
            battles = user_data.get('battle_wins', 0)
            mining_lvl = user_data.get('mining_level', 1)
            mafia_rank = get_mafia_rank(user_data.get('mafia_respect', 0))

            # Emoji dla pozycji
            emoji = position_emojis.get(i, f"{i}.")

            # Specjalne oznaczenia
            special = ""
            if points >= 500:
                special = " ğŸ‘‘"
            elif mafia_rank == 'Don':
                special = " ğŸ¤µ"
            elif points >= 100:
                special = " ğŸ’"
            elif battles >= 10:
                special = " âš”ï¸"
            elif mining_lvl >= 5:
                special = " â›ï¸"

            ranking_text += f"{emoji} **{username}**{special}\n"
            ranking_text += f"    ğŸ’ {points} pkt | âš”ï¸ {battles} | â›ï¸ Lvl{mining_lvl} | ğŸ¤µ {mafia_rank}\n\n"

        # Dodaj informacjÄ™ o aktualnym uÅ¼ytkowniku
        current_user_id = str(update.effective_user.id)
        if current_user_id in data:
            # ZnajdÅº pozycjÄ™ uÅ¼ytkownika w peÅ‚nym rankingu (wszyscy uÅ¼ytkownicy z punktami)
            all_sorted = sorted(users_with_info, key=lambda x: x[1]['points'], reverse=True)
            user_position = next((i for i, (uid, _, _) in enumerate(all_sorted, 1) if uid == current_user_id), None)

            if user_position:
                current_points = data[current_user_id].get('points', 0)
                if user_position <= 15:
                    ranking_text += f"ğŸ“ **Twoja pozycja: #{user_position}** ({current_points} pkt)"
                else:
                    ranking_text += f"ğŸ“ **Twoja pozycja: #{user_position}** ({current_points} pkt) - poza TOP 15"
            else:
                ranking_text += "ğŸ“ **Nie jesteÅ› jeszcze w rankingu!** (0 punktÃ³w)"

        else:
            ranking_text += "ğŸ“ **Nie jesteÅ› jeszcze zarejestrowany!**"


        # Dodaj statystyki ogÃ³lne
        total_active = len(users_with_info)
        ranking_text += f"\n\nğŸ‘¥ **ÅÄ…cznie aktywnych graczy: {total_active}**"

        await update.message.reply_text(ranking_text, parse_mode='Markdown')
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w ranking: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d w rankingu!")

async def bot_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        data = load_user_data()

        # Podstawowe statystyki
        total_users = len(data)
        total_points = sum(user_data.get('points', 0) for user_data in data.values())

        # Statystyki aktywnoÅ›ci
        active_users = sum(1 for user_data in data.values() if user_data.get('points', 0) > 0)
        total_battles = sum(user_data.get('battle_wins', 0) for user_data in data.values())

        # Statystyki mining
        miners = sum(1 for user_data in data.values() if user_data.get('mining_level', 1) > 1)
        avg_mining_level = sum(user_data.get('mining_level', 1) for user_data in data.values()) / max(total_users, 1)

        # Statystyki mafii
        mafia_members = sum(1 for user_data in data.values() if user_data.get('mafia_respect', 0) > 0)
        dons = sum(1 for user_data in data.values() if get_mafia_rank(user_data.get('mafia_respect', 0)) == 'Don')
        total_contracts = sum(user_data.get('contracts_completed', 0) for user_data in data.values())

        # Najlepszy gracz
        if data:
            top_player = max(data.items(), key=lambda x: x[1].get('points', 0))
            top_points = top_player[1].get('points', 0)
        else:
            top_points = 0

        # Statystyki odznak
        all_badges = []
        for user_data in data.values():
            all_badges.extend(user_data.get('badges', []))
        unique_badges = len(set(all_badges))
        total_badges = len(all_badges)

        stats_text = (
            "ğŸ“Š **STATYSTYKI MEGA BOTA DON MLEKO:**\n\n"
            f"ğŸ‘¥ **UÅ»YTKOWNICY:**\n"
            f"â€¢ ÅÄ…cznie uÅ¼ytkownikÃ³w: {total_users}\n"
            f"â€¢ Aktywni uÅ¼ytkownicy: {active_users}\n"
            f"â€¢ NajwyÅ¼szy wynik: {top_points:,}\n\n"
            f"ğŸ’ **PUNKTY I AKTYWNOÅšÄ†:**\n"
            f"â€¢ ÅÄ…czne punkty: {total_points:,}\n"
            f"â€¢ Åšrednia punktÃ³w/uÅ¼ytkownik: {total_points//max(total_users, 1):,}\n"
            f"â€¢ ÅÄ…czne bitwy wygrane: {total_battles}\n\n"
            f"â›ï¸ **MINING:**\n"
            f"â€¢ Aktywni gÃ³rnicy: {miners}\n"
            f"â€¢ Åšredni level mining: {avg_mining_level:.1f}\n\n"
            f"ğŸ¤µ **MAFIA:**\n"
            f"â€¢ CzÅ‚onkowie mafii: {mafia_members}\n"
            f"â€¢ Donowie: {dons}\n"
            f"â€¢ Wykonane kontrakty: {total_contracts}\n\n"
            f"ğŸ… **ODZNAKI:**\n"
            f"â€¢ RÃ³Å¼ne odznaki: {unique_badges}/15\n"
            f"â€¢ ÅÄ…cznie odznak: {total_badges}\n\n"
            f"ğŸ® **NOWE FUNCKJE:**\n"
            f"â€¢ ğŸ¤µ System mafii z misjami\n"
            f"â€¢ ğŸ² 4 nowe mini gry\n"
            f"â€¢ ğŸ’° System napadÃ³w i haraczy\n"
            f"â€¢ ğŸ† Rangi mafijne\n\n"
            f"ğŸ„ Mega bot dziaÅ‚a 24/7 dla rodziny!"
        )

        await update.message.reply_text(stats_text, parse_mode='Markdown')
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w bot_stats: {e}")
        await update.message.reply_text("âŒ BÅ‚Ä…d przy pobieraniu statystyk bota!")

async def random_responses(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.effective_user.id

        # SprawdÅº rate limiting
        can_proceed, message = check_rate_limit(user_id, "response")
        if not can_proceed:
            # Nie odpowiadaj na kaÅ¼dÄ… wiadomoÅ›Ä‡ jeÅ›li przekroczono limit
            return

        message_text = update.message.text.lower()

        responses = {
            "siema": "ğŸ„ Siema! Don Mleko pozdrawia!",
            "hej": "ğŸ‘‹ Hej! Jak leci z DMT?",
            "czeÅ›Ä‡": "ğŸ„ CzeÅ›Ä‡ czÅ‚onku rodziny!",
            "moon": "ğŸŒ™ Don Mleko juÅ¼ pakuje bagaÅ¼e!",
            "diamond hands": "ğŸ’âœ‹ DIAMOND HANDS FOREVER!",
            "paper hands": "ğŸ“„âœ‹ Pfff... Don Mleko nie aprobuje!",
            "mafia": "ğŸ¤µ Rozmawiasz z rodzinÄ…...",
            "boss": "ğŸ‘‘ Don Mleko jest jedynym bossem!",
            "napad": "ğŸ’° Czas na akcjÄ™!",
            "blackjack": "ğŸƒ Czujesz siÄ™ szczÄ™Å›liwy?",
            "koÅ›ci": "ğŸ² Czas na los!",
            "crash": "ğŸš€ Do gwiazd!"
        }

        for keyword, response in responses.items():
            if keyword in message_text:
                points, success = add_points_with_limit(user_id, 1)
                if success:
                    await update.message.reply_text(f"{response}\nğŸ’ +1 punkt! Masz: {points}")
                else:
                    await update.message.reply_text(f"{response}\nâš ï¸ Limit punktÃ³w osiÄ…gniÄ™ty! Masz: {points}")
                break
    except Exception as e:
        logging.error(f"BÅ‚Ä…d w responses: {e}")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Ultraodporny error handler - nigdy nie zatrzymuje bota"""
    try:
        error = context.error
        error_type = type(error).__name__
        error_str = str(error).lower()

        # Lista bÅ‚Ä™dÃ³w ktÃ³re sÄ… normalne i nie wymagajÄ… akcji
        ignored_errors = [
            'networkerror', 'readerror', 'connecterror', 'timeouterror', 'httperror',
            'sslerror', 'connectionerror', 'retryafter', 'forbidden', 'unauthorized',
            'telegramerror', 'invalidtoken', 'chatmigrated', 'badrequest', 'conflicterror',
            'chatnotfound', 'userisdeactivated', 'userisblocked', 'botblocked'
        ]

        # JeÅ›li bÅ‚Ä…d jest ignorowany - ciche logowanie
        if any(ignored in error_str for ignored in ignored_errors):
            if random.randint(1, 10) == 1:  # Loguj tylko co 10-ty bÅ‚Ä…d
                logging.info(f"ğŸ’š Normalna operacja: {error_type}")
            return

        # BÅ‚Ä™dy zwiÄ…zane z uÅ¼ytkownikiem - nie zatrzymuj bota
        if update and hasattr(update, 'effective_user'):
            logging.info(f"ğŸ‘¤ User error ({error_type}) - kontynuujÄ™")
            return

        # Inne bÅ‚Ä™dy - loguj ale nie zatrzymuj
        logging.warning(f"âš ï¸ {error_type} - bot kontynuuje pracÄ™")

    except Exception as handler_error:
        # Nawet jeÅ›li error handler ma bÅ‚Ä…d - nie zatrzymuj bota
        logging.warning(f"Error handler issue: {handler_error} - ignorujÄ™ i kontynuujÄ™")
        pass

# Stabilny bot runner z polling
async def run_bot(app):
    """Uruchamia bota z auto-restart i backoff"""
    backoff = 1
    while True:
        try:
            logging.info("ğŸš€ Starting polling...")
            await app.initialize()
            await app.start()
            await app.updater.start_polling(
                allowed_updates=Update.ALL_TYPES,
                drop_pending_updates=True,
                timeout=30,
                poll_interval=1.0
            )
            # Czekaj w nieskoÅ„czonej pÄ™tli dopÃ³ki bot nie zostanie zatrzymany
            while app.updater.running:
                await asyncio.sleep(1)

        except (NetworkError, TimedOut) as e:
            logging.warning(f"ğŸ”„ Polling error: {e}. Retry in {backoff}s")
            await asyncio.sleep(backoff)
            backoff = min(backoff * 2, 60)

        except Exception as e:
            logging.exception(f"ğŸ’€ Fatal error, restarting in 10s: {e}")
            await asyncio.sleep(10)
            backoff = 1

        finally:
            try:
                await app.updater.stop()
            except:
                pass
            try:
                await app.stop()
            except:
                pass
            try:
                await app.shutdown()
            except:
                pass

# GÅ‚Ã³wna funkcja async
async def main():
    """GÅ‚Ã³wna funkcja bota"""
    try:
        # Skonfiguruj sesjÄ™ aiohttp
        async def post_init(app):
            app.bot_data["session"] = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=60, connect=10)
            )

        async def post_shutdown(app):
            session = app.bot_data.get("session")
            if session and not session.closed:
                await session.close()

        # Zbuduj aplikacjÄ™
        app = (
            ApplicationBuilder()
            .token(TOKEN)
            .post_init(post_init)
            .post_shutdown(post_shutdown)
            .build()
        )

        # Dodaj error handler
        app.add_error_handler(error_handler)

        # Dodaj handlery komend
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("kurs", kurs))
        app.add_handler(CommandHandler("mem", mem))
        app.add_handler(CommandHandler("battle", battle))
        app.add_handler(CommandHandler("mine", mine))
        app.add_handler(CommandHandler("slots", slots))
        app.add_handler(CommandHandler("roulette", roulette))
        app.add_handler(CommandHandler("mafia", mafia_menu))
        app.add_handler(CommandHandler("missions", missions))
        app.add_handler(CommandHandler("heist", heist))
        app.add_handler(CommandHandler("territory", territory))
        app.add_handler(CommandHandler("protection", protection))
        app.add_handler(CommandHandler("recruit", recruit_member))
        app.add_handler(CommandHandler("chat", chat_system))
        app.add_handler(CommandHandler("bosses", show_bosses))
        app.add_handler(CommandHandler("city", city_overview))
        app.add_handler(CommandHandler("buildings", special_buildings))
        app.add_handler(CommandHandler("mining", advanced_mining))
        app.add_handler(CommandHandler("blackjack", blackjack))
        app.add_handler(CommandHandler("dice", dice_game))
        app.add_handler(CommandHandler("crash", crash_game))
        app.add_handler(CommandHandler("wheel", wheel_of_fortune))
        app.add_handler(CommandHandler("feed", social_feed))
        app.add_handler(CommandHandler("post", create_post))
        app.add_handler(CommandHandler("like", like_post))
        app.add_handler(CommandHandler("comment", comment_post))
        app.add_handler(CommandHandler("c", comment_post))  # SkrÃ³cona wersja
        app.add_handler(CommandHandler("read", read_post))
        app.add_handler(CommandHandler("myposts", my_posts))
        app.add_handler(CommandHandler("lottery", super_lottery))
        app.add_handler(CommandHandler("timetravel", time_travel))
        app.add_handler(CommandHandler("megaboost", mega_boost))
        app.add_handler(CommandHandler("godmode", god_mode))
        app.add_handler(CommandHandler("guild", guild_system))
        app.add_handler(CallbackQueryHandler(button_callback))
        app.add_handler(CommandHandler("help", help_command))
        app.add_handler(CommandHandler("punkty", punkty))
        app.add_handler(CommandHandler("stats", stats))
        app.add_handler(CommandHandler("ranking", ranking))
        app.add_handler(CommandHandler("botstats", bot_stats))
        app.add_handler(CommandHandler("admin", admin_stats))


        # Handler dla wiadomoÅ›ci tekstowych (niekomend)
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, random_responses))


        logging.info("ğŸ„ Don Mleko MEGA Bot v4.2 - ULTRA STABLE EDITION!")
        logging.info("âœ… Token zabezpieczony w zmiennej Å›rodowiskowej")
        logging.info("ğŸ”„ Auto-restart z backoff aktywny")
        logging.info("ğŸ”— Keep-alive serwer uruchomiony")
        logging.info("ğŸ‘ï¸ Watchdog monitoring aktywny")

        # Uruchom watchdog
        asyncio.create_task(watchdog())

        # Uruchom bota
        await run_bot(app)

    except Exception as e:
        logging.error(f"ğŸ’€ Critical error in main: {e}")
        sys.exit(1)

if __name__ == "__main__":
    # Uruchom keep-alive serwer w osobnym wÄ…tku
    threading.Thread(target=start_keepalive, daemon=True).start()

    # Uruchom gÅ‚Ã³wnÄ… aplikacjÄ™
    asyncio.run(main())