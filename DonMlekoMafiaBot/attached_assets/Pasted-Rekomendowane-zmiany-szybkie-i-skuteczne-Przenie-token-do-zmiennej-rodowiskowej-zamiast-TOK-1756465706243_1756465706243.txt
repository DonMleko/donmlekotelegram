Rekomendowane zmiany (szybkie i skuteczne)
Przenieś token do zmiennej środowiskowej
# zamiast: TOKEN = "...."
TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise RuntimeError("Missing BOT_TOKEN env var")
Na Replit ustaw BOT_TOKEN w Secrets.
Dodaj automatyczny restart z backoff (polling)
import asyncio
import logging
from telegram.error import NetworkError, TimedOut

async def run_bot(app):
    backoff = 1
    while True:
        try:
            logging.info("Starting polling...")
            await app.initialize()
            await app.start()
            await app.updater.start_polling(
                allowed_updates=Update.ALL_TYPES,
                drop_pending_updates=True,
                timeout=30,
                poll_interval=1.0
            )
            await app.updater.wait_until_closed()
            # jeśli updater się zamknie, spróbuj ponownie
        except (NetworkError, TimedOut) as e:
            logging.warning(f"Polling error: {e}. Retry in {backoff}s")
            await asyncio.sleep(backoff)
            backoff = min(backoff * 2, 60)
        except Exception as e:
            logging.exception(f"Fatal error, restarting in 10s: {e}")
            await asyncio.sleep(10)
        finally:
            try:
                await app.updater.stop()
            except:
                pass
            try:
                await app.stop()
            except:
                pass
            try:
                await app.shutdown()
            except:
                pass
Użyj współdzielonej sesji aiohttp (mniej timeoutów)
import aiohttp
from telegram.ext import ApplicationBuilder

async def post_init(app):
    app["session"] = aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=60, connect=10)
    )

async def post_shutdown(app):
    session = app.get("session")
    if session and not session.closed:
        await session.close()

app = (
    ApplicationBuilder()
    .token(TOKEN)
    .post_init(post_init)
    .post_shutdown(post_shutdown)
    .build()
)
Dodaj watchdog, który co X sekund robi prosty ping do siebie i loguje stan
async def watchdog():
    while True:
        logging.debug("watchdog: alive")
        await asyncio.sleep(30)

async def main():
    # ... zbuduj app, dodaj handlery ...
    asyncio.create_task(watchdog())
    await run_bot(app)

if __name__ == "__main__":
    asyncio.run(main())
Keep-alive na Replit (zapobiega usypianiu)
Utwórz prosty serwer http i pinguj go np. z UptimeRobot co 5 min.
# keep_alive.py
from aiohttp import web

async def health(request):
    return web.Response(text="ok")

def start_keepalive():
    app = web.Application()
    app.router.add_get("/", health)
    web.run_app(app, host="0.0.0.0", port=8080)
W main:

import threading
from keep_alive import start_keepalive

if __name__ == "__main__":
    threading.Thread(target=start_keepalive, daemon=True).start()
    asyncio.run(main())
Skonfiguruj UptimeRobot do pingowania https://twoj-repl-url.repl.co/.
Alternatywnie: webhook zamiast pollingu (stabilniejsze na Replit)
PUBLIC_URL = os.getenv("PUBLIC_URL")  # np. https://twoj-repl-url.repl.co
await app.bot.set_webhook(url=f"{PUBLIC_URL}/{TOKEN}")

await app.run_webhook(
    listen="0.0.0.0",
    port=8080,
    url_path=TOKEN,
    webhook_url=f"{PUBLIC_URL}/{TOKEN}",
    drop_pending_updates=True
)
Wtedy keep-alive (pkt 5) nadal warto trzymać.
Upewnij się, że Replit “Expose” port 8080.
Dodatkowo:
W handlerach dodaj try/except z logowaniem, żeby pojedynczy błąd nie ubił całej pętli.
Używaj drop_pending_updates=True, żeby nie zalało po przerwie.
Rozważ migrację z darmowego Replit na plan z “Always On” lub na inny host (Railway/Render/Fly.io/Hobby VPS) dla stabilności.
